# Story 5.1: Send Message with Attachments

**Epic:** 5 - Messaging & Cases  
**Story Number:** 5.1  
**Created:** 2025-10-04

---

## Status

**Draft**

---

## Story

**As a** UKNF Employee or External User,  
**I want to** send messages with file attachments,  
**So that** I can communicate and share documents.

---

## Acceptance Criteria

**Source:** `docs/prd/epic-5-messaging-cases.md` - Story 5.1

1. User can compose message with text content (required)
2. User can attach multiple files in allowed formats: PDF, DOC/DOCX, XLS/XLSX, CSV/TXT, MP3, ZIP
3. System validates file formats before accepting
4. System validates total unpacked file size doesn't exceed 100 MB
5. System rejects files exceeding size limit with clear error message
6. System scans files for viruses before accepting
7. System rejects files with viruses and notifies user
8. System rejects messages containing SPAM
9. Message requires recipient selection (entity or specific user)
10. Message is associated with context (standalone, access request, report, or case)
11. Upon sending, message status is set appropriately based on recipient type
12. Recipient receives email notification of new message
13. System logs message sending with timestamp and user ID

---

## Tasks / Subtasks

### Backend Tasks

- [ ] **Task 1: Create SendMessageCommand** (AC: 1, 2, 9, 10)
  - [ ] Create `SendMessageCommand.cs` in `Application/UknfPlatform.Application.Communication/Messages/Commands/`
  - [ ] Command properties (from AC 1, 9, 10):
    - Subject (string, required, max 500)
    - Body (string, required, max length)
    - RecipientType (enum: Entity, User) - AC 9
    - RecipientEntityId (long?, optional) - if recipient is entity
    - RecipientUserIds (List<Guid>?, optional) - if specific users
    - ContextType (enum: Standalone, AccessRequest, Report, Case) - AC 10
    - ContextId (Guid?, optional) - related context ID
    - ParentMessageId (Guid?, optional) - for threading
    - AttachmentFiles (List<IFormFile>) - uploaded files - AC 2

- [ ] **Task 2: Create SendMessageCommandValidator** (AC: 1, 2, 3, 4)
  - [ ] Create `SendMessageCommandValidator.cs` using FluentValidation
  - [ ] Validate Subject: NotEmpty, MaxLength(500)
  - [ ] Validate Body: NotEmpty
  - [ ] Validate RecipientType: Must be set
  - [ ] Validate recipient:  Either RecipientEntityId or RecipientUserIds must be provided
  - [ ] Validate ContextType: Must be valid enum value
  - [ ] Validate ContextId: Required if ContextType is not Standalone
  - [ ] Validate AttachmentFiles (AC 2, 3, 4):
    - Each file must have allowed extension (.pdf, .doc, .docx, .xls, .xlsx, .csv, .txt, .mp3, .zip)
    - Total size of all files ≤ 100 MB
    - If ZIP file, validate unpacked size ≤ 100 MB
  - [ ] Custom validator: `ValidateFileFormats` (check magic numbers, not just extension) - AC 3
  - [ ] Custom validator: `ValidateTotalFileSize` - AC 4

- [ ] **Task 3: Implement file format validation by magic numbers** (AC: 3)
  - [ ] Create `FileFormatValidator.cs` utility class in `Infrastructure`
  - [ ] Implement magic number detection for:
    - PDF: `%PDF-` (0x25 0x50 0x44 0x46)
    - DOC: `D0CF11E0A1B11AE1` (OLE2)
    - DOCX/XLSX: `504B0304` (ZIP with specific internal structure)
    - CSV/TXT: Validate as plain text
    - MP3: `ID3` or `FFFB`
    - ZIP: `504B0304`
  - [ ] Return ValidationResult with specific error if format doesn't match extension

- [ ] **Task 4: Implement ZIP file unpacking size validation** (AC: 4)
  - [ ] Create `ZipFileValidator.cs` utility
  - [ ] Extract ZIP and calculate total unpacked size
  - [ ] Reject if unpacked size > 100 MB
  - [ ] Do NOT extract malicious files (validate before unpack)

- [ ] **Task 5: Implement virus scanning service** (AC: 6, 7)
  - [ ] Create `IVirusScanningService.cs` interface in `Domain`
  - [ ] Method: `Task<VirusScanResult> ScanFileAsync(Stream fileStream, string fileName)`
  - [ ] Create implementation `VirusScanningService.cs` in `Infrastructure`
  - [ ] For HACKATHON: Stub implementation (always returns Clean)
  - [ ] For PRODUCTION: Integrate with ClamAV or similar
  - [ ] Return result: Clean, Infected, ScanError
  - [ ] If Infected: Return error message with virus name if available

- [ ] **Task 6: Implement SPAM detection** (AC: 8)
  - [ ] Create `ISpamDetectionService.cs` interface
  - [ ] Method: `Task<bool> IsSpamAsync(string subject, string body)`
  - [ ] Create implementation `SpamDetectionService.cs`
  - [ ] For HACKATHON: Simple heuristics (excessive links, suspicious keywords, all caps)
  - [ ] For PRODUCTION: Consider ML-based or external API integration
  - [ ] Keywords to flag: Common spam patterns
  - [ ] Return true if message likely SPAM

- [ ] **Task 7: Create SendMessageCommandHandler** (AC: All)
  - [ ] Create `SendMessageCommandHandler.cs` implementing `IRequestHandler<SendMessageCommand, SendMessageResponse>`
  - [ ] Inject: IMessageRepository, IFileStorageService, IVirusScanningService, ISpamDetectionService, IEmailService, ICurrentUserService, IUnitOfWork, ILogger
  - [ ] Handler logic:
    1. Get current user (sender)
    2. Validate SPAM (AC 8) - reject if spam detected
    3. Process attachments (AC 2-7):
       - Validate file formats by magic numbers (AC 3)
       - Validate total size ≤ 100 MB (AC 4)
       - Scan each file for viruses (AC 6)
       - If virus found: Reject with error (AC 7)
       - Upload clean files to file storage
    4. Determine message status based on sender type (AC 11):
       - If sender is External User: Status = "AwaitingUknfResponse"
       - If sender is UKNF Employee: Status = "AwaitingUserResponse"
    5. Create Message entity
    6. Create MessageAttachment entities for each file
    7. Determine recipients (AC 9):
       - If RecipientEntityId: Get all entity representatives
       - If RecipientUserIds: Use specified users
    8. Create MessageRecipient records
    9. Save to repository
    10. Send email notifications to recipients (AC 12)
    11. Log action (AC 13)
    12. Return SendMessageResponse with message ID
  - [ ] Use transaction via IUnitOfWork

- [ ] **Task 8: Create Message domain entity** (AC: All)
  - [ ] Update/verify `Message.cs` in `Domain/UknfPlatform.Domain.Communication/Entities/`
  - [ ] Properties (from data model):
    - Id (Guid)
    - Subject (string, max 500)
    - Body (string, max)
    - SenderId (Guid) - current user
    - MessageStatus (enum: AwaitingUknfResponse, AwaitingUserResponse, Closed) - AC 11
    - ContextType (enum: Standalone, AccessRequest, Report, Case) - AC 10
    - ContextId (Guid?)
    - EntityId (long?)
    - ParentMessageId (Guid?) - for threading
    - SentDate (DateTime)
    - ReadDate (DateTime?)
    - IsReadByRecipient (bool, default: false)
  - [ ] Relationships: Sender (User), Recipients (MessageRecipient), Attachments (MessageAttachment), ParentMessage

- [ ] **Task 9: Create MessageAttachment domain entity** (AC: 2)
  - [ ] Create `MessageAttachment.cs` in `Domain/UknfPlatform.Domain.Communication/Entities/`
  - [ ] Properties:
    - Id (Guid)
    - MessageId (Guid) - FK
    - FileName (string, max 500)
    - FileStorageKey (string, max 500) - object storage key
    - FileSize (long) - in bytes
    - ContentType (string) - MIME type
    - UploadedDate (DateTime)
  - [ ] Relationship: Many-to-One with Message

- [ ] **Task 10: Create MessageRecipient junction entity** (AC: 9)
  - [ ] Create `MessageRecipient.cs`
  - [ ] Properties:
    - Id (Guid)
    - MessageId (Guid) - FK
    - RecipientUserId (Guid) - FK
    - IsRead (bool, default: false)
    - ReadDate (DateTime?)
  - [ ] Used to track multiple recipients and individual read statuses

- [ ] **Task 11: Create database migrations** (AC: All)
  - [ ] Create EF Core migration: `Add_Messages_And_Attachments_Tables`
  - [ ] Schema:
    ```sql
    CREATE TABLE Messages (
        Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        Subject NVARCHAR(500) NOT NULL,
        Body NVARCHAR(MAX) NOT NULL,
        SenderId UUID NOT NULL,
        MessageStatus NVARCHAR(50) NOT NULL,
        ContextType NVARCHAR(50) NOT NULL,
        ContextId UUID NULL,
        EntityId BIGINT NULL,
        ParentMessageId UUID NULL,
        SentDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
        ReadDate DATETIME2 NULL,
        IsReadByRecipient BIT NOT NULL DEFAULT 0,
        
        FOREIGN KEY (SenderId) REFERENCES Users(Id),
        FOREIGN KEY (EntityId) REFERENCES Entities(Id),
        FOREIGN KEY (ParentMessageId) REFERENCES Messages(Id),
        INDEX IX_Messages_SenderId (SenderId),
        INDEX IX_Messages_ContextType_ContextId (ContextType, ContextId),
        INDEX IX_Messages_EntityId (EntityId),
        INDEX IX_Messages_MessageStatus (MessageStatus),
        INDEX IX_Messages_SentDate (SentDate DESC)
    );
    
    CREATE TABLE MessageAttachments (
        Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        MessageId UUID NOT NULL,
        FileName NVARCHAR(500) NOT NULL,
        FileStorageKey NVARCHAR(500) NOT NULL,
        FileSize BIGINT NOT NULL,
        ContentType NVARCHAR(100) NULL,
        UploadedDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
        
        FOREIGN KEY (MessageId) REFERENCES Messages(Id) ON DELETE CASCADE,
        INDEX IX_MessageAttachments_MessageId (MessageId)
    );
    
    CREATE TABLE MessageRecipients (
        Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        MessageId UUID NOT NULL,
        RecipientUserId UUID NOT NULL,
        IsRead BIT NOT NULL DEFAULT 0,
        ReadDate DATETIME2 NULL,
        
        FOREIGN KEY (MessageId) REFERENCES Messages(Id) ON DELETE CASCADE,
        FOREIGN KEY (RecipientUserId) REFERENCES Users(Id),
        INDEX IX_MessageRecipients_MessageId (MessageId),
        INDEX IX_MessageRecipients_RecipientUserId_IsRead (RecipientUserId, IsRead)
    );
    ```

- [ ] **Task 12: Create SendMessageResponse DTO** (AC: All)
  - [ ] Create `SendMessageResponse.cs` record
  - [ ] Properties:
    - MessageId (Guid)
    - SentDate (DateTime)
    - RecipientCount (int)
    - AttachmentCount (int)
    - Message (string) - e.g., "Message sent successfully to 3 recipients"

- [ ] **Task 13: Create REST API endpoint POST /api/messages** (AC: All)
  - [ ] Create `MessagesController.cs` in `Api/UknfPlatform.Api/Controllers/`
  - [ ] Add `[Authorize]` attribute
  - [ ] Create POST action `SendMessageAsync([FromForm] SendMessageRequest request)`
  - [ ] Use `[FromForm]` for multipart/form-data (file uploads)
  - [ ] Map request to SendMessageCommand
  - [ ] Send command via MediatR
  - [ ] Return 201 Created with SendMessageResponse
  - [ ] Return 400 if validation fails (invalid file format, size exceeded, virus detected, spam detected)
  - [ ] Return 403 if user lacks permission to message recipient
  - [ ] Add XML documentation comments and Swagger annotations

- [ ] **Task 14: Implement email notification for new message** (AC: 12)
  - [ ] Use IEmailService
  - [ ] Email template: "New Message from [Sender Name]"
  - [ ] Email body includes:
    - Sender name
    - Subject/preview of message
    - Link to view message in platform
    - Context if applicable (e.g., "Related to Case #12345")
  - [ ] Send to all recipients
  - [ ] Handle email errors gracefully (log but don't fail message send)

- [ ] **Task 15: Implement audit logging** (AC: 13)
  - [ ] Log to AuditLog table
  - [ ] Log details:
    - Action: "MessageSent"
    - UserId: Sender ID
    - Timestamp: SentDate
    - Details: Message ID, subject, recipient count, context type, context ID
  - [ ] Include IP address if available

### Frontend Tasks

- [ ] **Task 16: Create messages service** (AC: All)
  - [ ] Create `messages.service.ts` in `core/services/`
  - [ ] Method: `sendMessage(command: SendMessageRequest): Observable<SendMessageResponse>`
  - [ ] Use HttpClient with multipart/form-data for file uploads
  - [ ] Handle file upload progress (optional)

- [ ] **Task 17: Create compose message component** (AC: 1, 2, 9, 10)
  - [ ] Create `compose-message.component.ts` in `features/messaging/`
  - [ ] Can be used as standalone page or dialog
  - [ ] Form fields (AC 1, 9, 10):
    - Recipient selector (entity or user dropdown) - AC 9
    - Subject (input, required)
    - Body (textarea, required)
    - Context (dropdown: Standalone, Access Request, Report, Case) - AC 10
    - Context ID (if context selected)
    - File attachments (file uploader) - AC 2
  - [ ] Inject MessagesService

- [ ] **Task 18: Implement recipient selector** (AC: 9)
  - [ ] Radio buttons: "Send to Entity" or "Send to Specific Users"
  - [ ] If "Entity": Dropdown of entities (external users see their entities, UKNF sees all)
  - [ ] If "Specific Users": Multi-select dropdown of users
  - [ ] Use PrimeNG Dropdown/MultiSelect components

- [ ] **Task 19: Implement file uploader** (AC: 2, 3, 4, 5)
  - [ ] Use PrimeNG FileUpload component
  - [ ] Set `accept` attribute for allowed formats: ".pdf,.doc,.docx,.xls,.xlsx,.csv,.txt,.mp3,.zip" (AC 2)
  - [ ] Set `maxFileSize` to 100 MB (104857600 bytes) - AC 4
  - [ ] Allow multiple files
  - [ ] Display file list with:
    - File name
    - File size
    - Remove button
  - [ ] Calculate and display total size
  - [ ] If total size exceeds 100 MB: Show error message, disable submit (AC 5)

- [ ] **Task 20: Implement client-side file validation** (AC: 2, 3, 4, 5)
  - [ ] Validate file extensions match allowed formats (AC 2)
  - [ ] Validate individual file size ≤ 100 MB
  - [ ] Validate total size ≤ 100 MB (AC 4)
  - [ ] Show validation errors inline
  - [ ] Error messages (AC 5):
    - "File format not allowed. Allowed: PDF, DOC, DOCX, XLS, XLSX, CSV, TXT, MP3, ZIP"
    - "Total file size exceeds 100 MB limit. Please remove some files."

- [ ] **Task 21: Handle virus detection response** (AC: 6, 7)
  - [ ] If API returns 400 with virus detected error:
    - Display prominent error message: "File [filename] contains a virus and was rejected."
    - Highlight infected file in list
    - Allow user to remove infected file and retry
  - [ ] Use PrimeNG Message/Toast for notifications

- [ ] **Task 22: Handle SPAM detection response** (AC: 8)
  - [ ] If API returns 400 with SPAM detected error:
    - Display error message: "Message flagged as spam. Please review your content."
    - Highlight issue (e.g., excessive links, suspicious keywords)
    - Allow user to edit and resubmit

- [ ] **Task 23: Implement send message action** (AC: All)
  - [ ] "Send Message" button
  - [ ] On click:
    1. Validate form (all required fields)
    2. Validate files (AC 2-5)
    3. Create FormData with message fields and files
    4. Call messagesService.sendMessage()
    5. Show loading indicator
    6. On success (AC 12):
       - Display success message: "Message sent successfully to X recipients"
       - Close dialog/form
       - Refresh message list (if applicable)
       - Navigate to messages list or sent messages
    7. On error:
       - Display error message (virus, spam, size, etc.)
       - Keep form open for editing

- [ ] **Task 24: Create context selector** (AC: 10)
  - [ ] Dropdown for ContextType: Standalone, Access Request, Report, Case
  - [ ] If context selected (not Standalone):
    - Show additional field to select specific context (e.g., Case #12345, Report #67890)
    - Fetch related contexts based on user's access
  - [ ] If used within context (e.g., reply in case view): Pre-populate and disable selector

- [ ] **Task 25: Create page layout** (AC: All)
  - [ ] Page title: "Compose Message" or "Send Message"
  - [ ] Breadcrumb: Messages > Compose
  - [ ] Form layout:
    - Recipient section (entity or user selector)
    - Context section (optional)
    - Subject field
    - Body field (large textarea with formatting options, optional)
    - Attachments section (file uploader)
    - Total size indicator
    - Submit button: "Send Message"
    - Cancel button
  - [ ] Use PrimeNG Card, InputText, InputTextarea, FileUpload components
  - [ ] Style with Tailwind CSS
  - [ ] Responsive design

### Testing Tasks

- [ ] **Task 26: Write unit tests for SendMessageCommandValidator**
  - [ ] Test: `Validate_ValidMessage_Passes` (AC 1)
  - [ ] Test: `Validate_MissingSubject_Fails` (AC 1)
  - [ ] Test: `Validate_MissingBody_Fails` (AC 1)
  - [ ] Test: `Validate_NoRecipient_Fails` (AC 9)
  - [ ] Test: `Validate_InvalidFileExtension_Fails` (AC 2, 3)
  - [ ] Test: `Validate_TotalSizeExceeds100MB_Fails` (AC 4)
  - [ ] Test: `Validate_ZipUnpackedSizeExceeds100MB_Fails` (AC 4)

- [ ] **Task 27: Write unit tests for FileFormatValidator**
  - [ ] Test: `ValidatePdf_CorrectMagicNumbers_ReturnsValid` (AC 3)
  - [ ] Test: `ValidateDocx_CorrectMagicNumbers_ReturnsValid` (AC 3)
  - [ ] Test: `ValidateZip_CorrectMagicNumbers_ReturnsValid` (AC 3)
  - [ ] Test: `ValidateFile_WrongMagicNumbers_ReturnsInvalid` (AC 3)
  - [ ] Create test files with correct/incorrect magic numbers

- [ ] **Task 28: Write unit tests for VirusScanningService**
  - [ ] Test: `ScanFile_CleanFile_ReturnsClean` (AC 6)
  - [ ] Test: `ScanFile_InfectedFile_ReturnsInfected` (AC 7)
  - [ ] Mock virus scanner for testing

- [ ] **Task 29: Write unit tests for SendMessageCommandHandler**
  - [ ] Test: `Handle_ValidMessage_SendsSuccessfully` (AC All)
  - [ ] Test: `Handle_SpamDetected_ThrowsValidationException` (AC 8)
  - [ ] Test: `Handle_VirusDetected_ThrowsValidationException` (AC 6, 7)
  - [ ] Test: `Handle_ExternalUserSender_SetsAwaitingUknfStatus` (AC 11)
  - [ ] Test: `Handle_UknfEmployeeSender_SetsAwaitingUserStatus` (AC 11)
  - [ ] Test: `Handle_EntityRecipient_CreatesRecipientForAllRepresentatives` (AC 9)
  - [ ] Test: `Handle_SendsEmailNotifications` (AC 12)
  - [ ] Mock: IMessageRepository, IFileStorageService, IVirusScanningService, IEmailService

- [ ] **Task 30: Write integration test for send message endpoint**
  - [ ] Test: `POST_SendMessage_ValidRequest_Returns201` (AC All)
  - [ ] Test: `POST_SendMessage_WithAttachments_StoresFiles` (AC 2)
  - [ ] Test: `POST_SendMessage_InvalidFileFormat_Returns400` (AC 3)
  - [ ] Test: `POST_SendMessage_SizeExceeds100MB_Returns400` (AC 4, 5)
  - [ ] Test: `POST_SendMessage_VirusDetected_Returns400` (AC 6, 7)
  - [ ] Test: `POST_SendMessage_SpamDetected_Returns400` (AC 8)
  - [ ] Verify message created in database
  - [ ] Verify attachments stored in file storage
  - [ ] Verify email notification sent (AC 12)
  - [ ] Verify audit log created (AC 13)

- [ ] **Task 31: Write E2E test for compose and send message**
  - [ ] Test workflow:
    1. Login as external user
    2. Navigate to "Compose Message"
    3. Select recipient (entity) (AC 9)
    4. Select context: Standalone (AC 10)
    5. Enter subject (AC 1)
    6. Enter body (AC 1)
    7. Upload PDF file (AC 2)
    8. Upload DOCX file (AC 2)
    9. Verify total size displayed
    10. Click "Send Message"
    11. Verify success message displayed
    12. Verify redirected to messages list
    13. Login as UKNF employee
    14. Navigate to messages
    15. Verify message appears with status "Awaits UKNF's response" (AC 11)
    16. Verify email notification sent (check email in MailDev) (AC 12)
  - [ ] Use Cypress or Playwright

---

## Dev Notes

### Previous Story Context

**From Epic 2 (Access Requests) and Epic 4 (Reports):**
- Messaging can be used within access requests and reports
- This story establishes the foundational messaging system
- Future stories will integrate messaging into those contexts

### Architecture Context

**Source:** `docs/architecture/section-3-tech-stack.md`

**Backend Stack:**
- Language: C# 12.0
- Runtime: .NET 8.0 LTS
- ORM: Entity Framework Core 8.0
- CQRS: MediatR 12.4.0
- File Storage: MinIO (S3-compatible)
- Virus Scanning: ClamAV (or stub for hackathon)

**Frontend Stack:**
- Framework: Angular 20.x
- UI Library: PrimeNG (FileUpload, Dropdown, MultiSelect, Message, Card)
- Styling: Tailwind CSS

### Project Structure

**Source:** `docs/architecture/section-10-source-tree.md`

Backend files location:
```
src/Backend/
├── Api/UknfPlatform.Api/Controllers/
│   └── MessagesController.cs (CREATE)
├── Application/UknfPlatform.Application.Communication/Messages/
│   ├── Commands/
│   │   ├── SendMessageCommand.cs (CREATE)
│   │   ├── SendMessageCommandHandler.cs (CREATE)
│   │   └── SendMessageCommandValidator.cs (CREATE)
│   └── DTOs/
│       ├── SendMessageRequest.cs (CREATE)
│       └── SendMessageResponse.cs (CREATE)
├── Domain/UknfPlatform.Domain.Communication/
│   ├── Entities/
│   │   ├── Message.cs (CREATE)
│   │   ├── MessageAttachment.cs (CREATE)
│   │   └── MessageRecipient.cs (CREATE)
│   └── Services/
│       ├── IVirusScanningService.cs (CREATE)
│       └── ISpamDetectionService.cs (CREATE)
└── Infrastructure/UknfPlatform.Infrastructure/
    ├── Services/
    │   ├── VirusScanningService.cs (CREATE)
    │   ├── SpamDetectionService.cs (CREATE)
    │   ├── FileFormatValidator.cs (CREATE)
    │   └── ZipFileValidator.cs (CREATE)
    └── Persistence/Migrations/
        └── Add_Messages_And_Attachments_Tables.cs (CREATE)
```

Frontend files location:
```
src/Frontend/uknf-platform-ui/src/app/
├── core/services/
│   └── messages.service.ts (CREATE)
└── features/messaging/
    ├── compose-message/
    │   ├── compose-message.component.ts (CREATE)
    │   ├── compose-message.component.html (CREATE)
    │   └── compose-message.component.scss (CREATE)
    └── components/
        ├── recipient-selector.component.ts (CREATE)
        └── file-uploader.component.ts (CREATE - optional, can use PrimeNG directly)
```

### Data Models

**Source:** `docs/architecture/section-4-data-models.md`

**Message Entity:**
- Id (Guid)
- Subject (string, max 500)
- Body (string, max)
- SenderId (Guid)
- MessageStatus (enum)
- ContextType (enum)
- ContextId (Guid?)
- EntityId (long?)
- ParentMessageId (Guid?)
- SentDate (DateTime)
- ReadDate (DateTime?)
- IsReadByRecipient (bool)

**MessageAttachment Entity:**
- Id (Guid)
- MessageId (Guid)
- FileName (string, max 500)
- FileStorageKey (string, max 500)
- FileSize (long)
- ContentType (string)
- UploadedDate (DateTime)

**MessageRecipient Entity:**
- Id (Guid)
- MessageId (Guid)
- RecipientUserId (Guid)
- IsRead (bool)
- ReadDate (DateTime?)

### REST API Specification

**Endpoint:** POST `/api/messages`
- **Security:** Requires authentication
- **Content-Type:** multipart/form-data
- **Request:**
  ```
  FormData:
  - subject: string
  - body: string
  - recipientType: "Entity" | "User"
  - recipientEntityId: long? (if recipientType = Entity)
  - recipientUserIds: Guid[]? (if recipientType = User)
  - contextType: "Standalone" | "AccessRequest" | "Report" | "Case"
  - contextId: Guid? (if not Standalone)
  - files: File[] (multiple files)
  ```
- **Response (201 Created):**
  ```json
  {
    "messageId": "guid",
    "sentDate": "2025-10-04T10:00:00Z",
    "recipientCount": 3,
    "attachmentCount": 2,
    "message": "Message sent successfully to 3 recipients"
  }
  ```
- **Error Responses:**
  - 400 Bad Request: Validation errors (invalid format, size exceeded, virus, spam)
  - 403 Forbidden: User lacks permission to message recipient
  - 413 Payload Too Large: File size exceeds limit

### Coding Standards

**Source:** `docs/architecture/section-13-coding-standards.md`

**CRITICAL RULES:**

1. **File format validation by magic numbers (AC 3)**
   ```csharp
   // ✅ CORRECT
   public static bool IsPdf(Stream stream)
   {
       stream.Position = 0;
       byte[] buffer = new byte[4];
       stream.Read(buffer, 0, 4);
       return buffer[0] == 0x25 && buffer[1] == 0x50 && 
              buffer[2] == 0x44 && buffer[3] == 0x46; // %PDF
   }
   ```

2. **Virus scanning (AC 6, 7)**
   ```csharp
   // ✅ CORRECT
   foreach (var file in command.AttachmentFiles)
   {
       var scanResult = await _virusScanningService.ScanFileAsync(file.OpenReadStream(), file.FileName);
       if (scanResult.IsInfected)
       {
           throw new ValidationException($"File '{file.FileName}' contains a virus: {scanResult.VirusName}");
       }
   }
   ```

3. **Set message status based on sender type (AC 11)**
   ```csharp
   // ✅ CORRECT
   var sender = await _userService.GetByIdAsync(currentUserId);
   var messageStatus = sender.UserType == UserType.External 
       ? MessageStatus.AwaitingUknfResponse 
       : MessageStatus.AwaitingUserResponse;
   ```

4. **Determine recipients for entity (AC 9)**
   ```csharp
   // ✅ CORRECT
   if (command.RecipientEntityId.HasValue)
   {
       var entityRepresentatives = await _userEntityRepository
           .GetUsersByEntityIdAsync(command.RecipientEntityId.Value);
       
       foreach (var user in entityRepresentatives)
       {
           recipients.Add(new MessageRecipient
           {
               MessageId = message.Id,
               RecipientUserId = user.Id
           });
       }
   }
   ```

5. **Upload files to storage**
   ```csharp
   // ✅ CORRECT
   foreach (var file in command.AttachmentFiles)
   {
       var storageKey = $"messages/{message.Id}/{Guid.NewGuid()}_{file.FileName}";
       await _fileStorageService.UploadAsync(storageKey, file.OpenReadStream(), file.ContentType);
       
       var attachment = new MessageAttachment
       {
           MessageId = message.Id,
           FileName = file.FileName,
           FileStorageKey = storageKey,
           FileSize = file.Length,
           ContentType = file.ContentType
       };
       
       message.Attachments.Add(attachment);
   }
   ```

### File Attachment Rules

**Source:** `docs/prd/epic-5-messaging-cases.md` - Technical Considerations

- **Allowed formats:** PDF, DOC/DOCX, XLS/XLSX, CSV/TXT, MP3, ZIP
- **Size limit:** 100 MB total for unpacked files
- **Validation:** Check format by magic numbers, not just extension (AC 3)
- **Security:** Scan all files for viruses (AC 6, 7)
- **SPAM:** Detect and reject spam messages (AC 8)
- **Storage:** Store securely in MinIO with backup

### Security Requirements

- Only authenticated users can send messages
- External users can message:
  - Their entity representatives
  - UKNF employees (in context of their entity)
- UKNF employees can message:
  - Any entity
  - Other UKNF employees
- File downloads require authentication and authorization
- Audit all message sends (AC 13)

### Performance Considerations

**Source:** `docs/prd/b-specification-of-non-functional-requirements.md#3-performance-and-scalability`

- File uploads should be chunked for large files (>10 MB)
- Virus scanning should not block user experience excessively
  - Consider async processing with status update for very large files
  - For hackathon: Stub virus scanning (instant response)
- File format validation by magic numbers is fast (read first few bytes)
- SPAM detection should be fast (< 1 second)

### Testing

**Source:** `docs/architecture/section-14-test-strategy-and-standards.md`

**Test Framework:** xUnit 2.6.6  
**Key test scenarios:**
- Send message with valid attachments
- Reject message with invalid file format
- Reject message exceeding size limit
- Reject message with virus
- Reject spam message
- Set correct message status based on sender type
- Send email notifications to recipients
- Create audit log entry

**Example:**
```csharp
[Fact]
public async Task Handle_ValidMessage_SendsSuccessfully()
{
    // Arrange - AC 1, 2, 9, 10, 11, 12, 13
    var currentUser = CreateExternalUser();
    var entity = CreateTestEntity();
    var pdfFile = CreateMockPdfFile();
    
    var command = new SendMessageCommand
    {
        Subject = "Test Message",
        Body = "Test body content",
        RecipientType = RecipientType.Entity,
        RecipientEntityId = entity.Id,
        ContextType = ContextType.Standalone,
        AttachmentFiles = new List<IFormFile> { pdfFile }
    };
    
    _currentUserService.GetCurrentUserId().Returns(currentUser.Id);
    _virusScanningService.ScanFileAsync(Arg.Any<Stream>(), Arg.Any<string>())
        .Returns(new VirusScanResult { IsInfected = false });
    _spamDetectionService.IsSpamAsync(Arg.Any<string>(), Arg.Any<string>())
        .Returns(false);
    
    // Act
    var result = await _handler.Handle(command, CancellationToken.None);
    
    // Assert
    result.MessageId.Should().NotBeEmpty();
    result.RecipientCount.Should().BeGreaterThan(0);
    result.AttachmentCount.Should().Be(1);
    
    // Verify message created with correct status (AC 11)
    var message = await _context.Messages.FindAsync(result.MessageId);
    message.MessageStatus.Should().Be(MessageStatus.AwaitingUknfResponse);
    
    // Verify email sent (AC 12)
    await _emailService.Received(1).SendAsync(Arg.Any<Email>());
    
    // Verify audit log (AC 13)
    var auditLog = await _context.AuditLogs
        .FirstOrDefaultAsync(a => a.Action == "MessageSent");
    auditLog.Should().NotBeNull();
}
```

### Additional Notes

1. **Message Threading:** ParentMessageId enables threaded conversations. This story creates messages; Story 5.3 implements replies with threading.

2. **Context Integration:** Messages can be standalone or associated with access requests (Epic 2), reports (Epic 4), or cases (Epic 5). Context provides additional filtering and organization.

3. **ZIP File Validation:** Unpacking ZIP to validate size is security-sensitive. Ensure:
   - Limit unpacked size to prevent ZIP bombs
   - Don't execute or fully extract files
   - Validate before unpack

4. **Virus Scanning Stub:** For hackathon, always return "Clean". For production, integrate ClamAV or commercial scanner.

5. **SPAM Detection:** Simple heuristics for hackathon:
   - More than 5 URLs in body
   - All-caps subject
   - Common spam keywords (e.g., "click here", "free money")
   - For production, consider ML-based solution

6. **Email Notifications:** Use existing IEmailService. Template should be user-friendly and include link to view message.

7. **Recipient Resolution:** If RecipientEntityId provided, system fetches all entity representatives from UserEntity junction table.

8. **File Storage:** Store in MinIO with path: `messages/{messageId}/{uniqueFileName}`. Ensures organization and uniqueness.

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Story created from Epic 5, strictly following PRD AC | Scrum Master (AI) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_This section will be populated by QA agent after story completion._

