# Story 4.2: External Validation Integration

**Epic:** 4 - Reporting System  
**Story Number:** 4.2  
**Created:** 2025-10-04

---

## Status

**Draft**

---

## Story

**As the** system,  
**I want to** send uploaded reports to the external validation service,  
**So that** reports can be checked for technical and substantive compliance.

---

## Acceptance Criteria

1. System sends report file to external validation service API immediately after upload
2. Report status changes from "Working" to "Transmitted" when sent successfully
3. System receives unique validation ID from external service
4. Report status changes to "Ongoing" when validation processing begins
5. System polls external service or receives webhooks for validation progress
6. System handles validation service errors gracefully (connection issues, service downtime)
7. If validation doesn't complete within 24 hours, status changes to "Error - Exceeded time"
8. System stores validation service response/results
9. System logs all interactions with validation service

---

## Tasks / Subtasks

### Backend Tasks

- [ ] **Task 1: Create IValidationService interface** (AC: 1, 3)
  - [ ] Create `IValidationService.cs` in `Application/UknfPlatform.Application.Shared/Interfaces/`
  - [ ] Methods:
    - `SubmitReportForValidationAsync(reportId, fileStream, metadata): Task<ValidationSubmissionResponse>`
    - `GetValidationStatusAsync(validationId): Task<ValidationStatusResponse>`
    - `GetValidationResultAsync(validationId): Task<ValidationResultResponse>`
    - `CancelValidationAsync(validationId): Task`
  - [ ] Response DTOs:
    - ValidationSubmissionResponse: UniqueValidationId, Status, SubmittedAt
    - ValidationStatusResponse: ValidationId, Status, Progress, EstimatedCompletion
    - ValidationResultResponse: ValidationId, Status, ResultFileUrl, Errors[], Warnings[]

- [ ] **Task 2: Create mock ValidationService implementation** (AC: 1, 3, 8)
  - [ ] Create `MockValidationService.cs` in `Infrastructure/UknfPlatform.Infrastructure.Validation/Services/`
  - [ ] Note: For hackathon, this is a self-hosted mock service, not truly external
  - [ ] Inject IFileStorageService, ILogger
  - [ ] SubmitReportForValidationAsync logic:
    - Generate unique validation ID (Guid)
    - Store file reference for processing
    - Return ValidationSubmissionResponse with ID and "Transmitted" status
    - Initiate async validation (publish to worker queue)
  - [ ] GetValidationStatusAsync logic:
    - Query validation job status from database or cache
    - Return current status and progress
  - [ ] GetValidationResultAsync logic:
    - Retrieve validation result from database
    - Return result with errors/warnings and result PDF URL
  - [ ] Use ClosedXML to parse XLSX files
  - [ ] Use QuestPDF to generate validation result PDF

- [ ] **Task 3: Create Report Validator Worker** (AC: 4, 5, 6, 7, 8)
  - [ ] Create `ReportValidatorWorker.cs` in `Workers/UknfPlatform.Workers.Validation/`
  - [ ] BackgroundService that consumes RabbitMQ messages
  - [ ] Inject IReportRepository, IFileStorageService, IValidationService, INotificationService, ILogger, IUnitOfWork
  - [ ] Worker logic:
    1. Consume ReportValidationJob from queue
    2. Update report status: Transmitted → Ongoing
    3. Fetch report metadata from database
    4. Download report file from blob storage
    5. Call mock validator to process file
    6. Handle validation result:
       - Success: Update status to "Successful", store result PDF
       - Errors: Update status to "ValidationErrors", store errors and result PDF
       - Technical error: Update status to "TechnicalError", log error
    7. Send notification to user (email + SignalR)
    8. Update validation timestamps
    9. Commit transaction
  - [ ] Error handling: Retry logic with exponential backoff
  - [ ] Timeout handling: If processing takes > 24 hours, set status to "TimeoutError"

- [ ] **Task 4: Implement mock validation logic** (AC: 1, 8)
  - [ ] Create `MockReportValidator.cs` utility class
  - [ ] Method: `ValidateReportAsync(stream, reportType, reportingPeriod): Task<ValidationResult>`
  - [ ] Validation logic:
    - Parse XLSX file using ClosedXML
    - Check file structure (valid Excel format)
    - Check for required worksheets based on report type
    - Use test file logic: 
      * Files with "Q1" in period → pass validation
      * Files with "Q2" in period → fail with errors
    - Validate data completeness (required columns, non-empty cells)
    - Check data types (numeric fields, date fields)
    - Apply business rules (e.g., totals match, percentages valid)
  - [ ] Return ValidationResult with:
    - IsValid (bool)
    - Errors[] (list of validation errors with line/column references)
    - Warnings[] (non-critical issues)
    - Metadata extracted from file

- [ ] **Task 5: Generate validation result PDF** (AC: 8)
  - [ ] Create `ValidationResultPdfGenerator.cs` using QuestPDF
  - [ ] Method: `GeneratePdfAsync(validationResult, reportMetadata): Task<Stream>`
  - [ ] PDF content (matching UKNF format from PRD):
    - UKNF logo and markings
    - Report file name
    - Receipt date (submission timestamp)
    - Validation date (completion timestamp)
    - Entity name and UKNF code
    - Validation status (success or errors)
    - List of errors with descriptions and locations
    - List of warnings (if any)
    - Unique validation ID
    - Footer with generation timestamp
  - [ ] Save PDF to blob storage
  - [ ] Return storage key

- [ ] **Task 6: Create ReportValidationJob message** (AC: 1, 2)
  - [ ] Create `ReportValidationJob.cs` in `Domain/UknfPlatform.Domain.Communication/Messages/`
  - [ ] Message properties:
    - ReportId (Guid)
    - EntityId (long)
    - UserId (Guid)
    - FileName (string)
    - FileStorageKey (string)
    - ReportType (string)
    - ReportingPeriod (string)
    - SubmittedDate (DateTime)
  - [ ] Published to RabbitMQ queue: "report-validation-queue"

- [ ] **Task 7: Publish ReportValidationJob from SubmitReportCommandHandler** (AC: 1)
  - [ ] Update Story 4.1's SubmitReportCommandHandler
  - [ ] After saving report with status "Working":
    - Publish ReportValidationJob to message queue
    - Update report status to "Transmitted"
    - Set UniqueValidationId from validation service response
    - Log transmission
  - [ ] Use IMessageBus or MassTransit to publish

- [ ] **Task 8: Create ValidationResult entity** (AC: 8)
  - [ ] Create `ValidationResult.cs` in `Domain/UknfPlatform.Domain.Communication/Entities/`
  - [ ] Properties:
    - Id (Guid)
    - ReportId (Guid, foreign key)
    - UniqueValidationId (string)
    - Status (enum: Ongoing, Successful, ValidationErrors, TechnicalError, TimeoutError)
    - ValidationStartedDate (DateTime)
    - ValidationCompletedDate (DateTime?)
    - ResultFileStorageKey (string?) - PDF result
    - IsValid (bool)
    - Errors (JSON or collection) - list of validation errors
    - Warnings (JSON or collection)
    - ExtractedMetadata (JSON) - metadata from file
    - TechnicalErrorMessage (string?)
    - CreatedDate (DateTime)
    - UpdatedDate (DateTime)
  - [ ] Relationships: Many-to-One with Report

- [ ] **Task 9: Create database migration for ValidationResults table** (AC: 8)
  - [ ] Create EF Core migration: `Add_ValidationResults_Table`
  - [ ] Schema:
    ```sql
    CREATE TABLE ValidationResults (
        Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        ReportId UUID NOT NULL,
        UniqueValidationId NVARCHAR(100) NOT NULL,
        Status NVARCHAR(50) NOT NULL CHECK (Status IN (
            'Ongoing', 'Successful', 'ValidationErrors', 'TechnicalError', 'TimeoutError'
        )),
        ValidationStartedDate DATETIME2 NOT NULL,
        ValidationCompletedDate DATETIME2 NULL,
        ResultFileStorageKey NVARCHAR(500) NULL,
        IsValid BIT NOT NULL DEFAULT 0,
        Errors NVARCHAR(MAX) NULL, -- JSON array
        Warnings NVARCHAR(MAX) NULL, -- JSON array
        ExtractedMetadata NVARCHAR(MAX) NULL, -- JSON object
        TechnicalErrorMessage NVARCHAR(MAX) NULL,
        CreatedDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
        UpdatedDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
        
        FOREIGN KEY (ReportId) REFERENCES Reports(Id),
        INDEX IX_ValidationResults_ReportId (ReportId),
        INDEX IX_ValidationResults_UniqueValidationId (UniqueValidationId),
        INDEX IX_ValidationResults_Status (Status)
    );
    ```

- [ ] **Task 10: Implement 24-hour timeout mechanism** (AC: 7)
  - [ ] Create `ValidationTimeoutWorker.cs` background service
  - [ ] Runs every hour (or configurable interval)
  - [ ] Query reports with status "Ongoing" where ValidationStartedDate > 24 hours ago
  - [ ] For each timed-out report:
    - Update status to "TimeoutError"
    - Set ErrorDescription = "Validation exceeded 24-hour time limit"
    - Send notification to user
    - Log timeout event
  - [ ] Use Hangfire or Quartz.NET for scheduled job (or simple BackgroundService with timer)

- [ ] **Task 11: Handle validation service errors** (AC: 6)
  - [ ] In ReportValidatorWorker, implement try-catch blocks
  - [ ] Handle connection errors:
    - Log error with details
    - Retry up to 3 times with exponential backoff
    - If all retries fail, set status to "TechnicalError"
    - Store error message in ErrorDescription
  - [ ] Handle parsing errors (corrupted XLSX):
    - Set status to "TechnicalError"
    - Error message: "File could not be parsed. Please ensure it's a valid Excel file."
  - [ ] Handle unexpected exceptions:
    - Log full exception stack trace
    - Set status to "TechnicalError"
    - Generic error message to user

- [ ] **Task 12: Update Report entity with validation methods** (AC: 2, 4)
  - [ ] Update Report.cs from Story 4.1
  - [ ] Add domain methods:
    - `TransmitForValidation(uniqueValidationId)`: Set status to Transmitted, store validation ID
    - `StartValidation()`: Set status to Ongoing, set ValidationStartedDate
    - `CompleteValidation(isValid, errors, resultFileKey)`: Set final status, store result
    - `MarkAsTimedOut()`: Set status to TimeoutError
    - `MarkAsTechnicalError(errorMessage)`: Set status to TechnicalError
  - [ ] Validate status transitions (state machine pattern)
  - [ ] Prevent invalid transitions (e.g., Working → Successful without Ongoing)

- [ ] **Task 13: Send real-time notifications via SignalR** (AC: 5)
  - [ ] Create `INotificationHub` interface for SignalR
  - [ ] Create `NotificationHub.cs` in `Api/UknfPlatform.Api/Hubs/`
  - [ ] Hub methods:
    - `SendReportStatusUpdate(userId, reportId, status)`
  - [ ] In ReportValidatorWorker, after each status change:
    - Call SignalR hub to push update to connected user
  - [ ] Frontend subscribes to hub on report details/list page
  - [ ] Show real-time status updates without page refresh

- [ ] **Task 14: Send email notifications** (AC: 5)
  - [ ] After validation completes (success or error), send email to submitter
  - [ ] Email for successful validation:
    - Subject: "Report Validation Successful - [Report Name]"
    - Body: "Your report has been validated successfully. View details: [Link]"
  - [ ] Email for validation errors:
    - Subject: "Report Validation Errors - [Report Name]"
    - Body: "Your report has validation errors. Please review and submit a correction. View details: [Link]"
    - Attach validation result PDF
  - [ ] Email for technical error:
    - Subject: "Report Validation Failed - [Report Name]"
    - Body: "Technical error during validation. Please contact support. Report ID: [ID]"
  - [ ] Use IEmailService (MailDev for demo)

- [ ] **Task 15: Configure RabbitMQ integration** (AC: 1)
  - [ ] Install MassTransit.RabbitMQ package
  - [ ] Configure in Program.cs:
    ```csharp
    builder.Services.AddMassTransit(x =>
    {
        x.AddConsumer<ReportValidatorWorker>();
        
        x.UsingRabbitMq((context, cfg) =>
        {
            cfg.Host("rabbitmq", "/", h =>
            {
                h.Username("guest");
                h.Password("guest");
            });
            
            cfg.ReceiveEndpoint("report-validation-queue", e =>
            {
                e.ConfigureConsumer<ReportValidatorWorker>(context);
                e.PrefetchCount = 5; // Process 5 reports concurrently
                e.UseConcurrencyLimit(5);
            });
        });
    });
    ```
  - [ ] Configure queue durability and retry policies
  - [ ] Set message TTL to 24 hours

- [ ] **Task 16: Log all validation interactions** (AC: 9)
  - [ ] Use structured logging with Serilog
  - [ ] Log events:
    - Report submitted for validation (ReportId, EntityId, UserId)
    - Validation job picked up by worker
    - Validation started (ReportId, ValidationId)
    - Validation completed (ReportId, Status, Duration)
    - Validation errors found (ReportId, ErrorCount)
    - Technical errors (ReportId, Exception)
    - Timeout (ReportId, Duration)
  - [ ] Include correlation ID for tracing entire workflow
  - [ ] Log to database (Serilog sink) and console

### Frontend Tasks

- [ ] **Task 17: Implement SignalR connection** (AC: 5)
  - [ ] Install @microsoft/signalr package
  - [ ] Create `src/Frontend/uknf-platform-ui/src/app/core/services/notification-hub.service.ts`
  - [ ] Establish SignalR connection to `/hubs/notifications`
  - [ ] Subscribe to report status updates
  - [ ] Service methods:
    - `connect()`: Establish connection
    - `disconnect()`: Close connection
    - `onReportStatusUpdate(callback)`: Subscribe to report updates
  - [ ] Auto-reconnect on connection loss

- [ ] **Task 18: Show real-time status updates in report details** (AC: 5)
  - [ ] Update report details component from Story 4.7
  - [ ] Subscribe to SignalR notifications
  - [ ] On status update event:
    - Update status badge in UI
    - Show notification toast
    - Refresh report details if needed
  - [ ] Visual feedback: Loading spinner while "Ongoing"

- [ ] **Task 19: Show real-time status updates in reports list** (AC: 5)
  - [ ] Update reports list component from Story 4.5
  - [ ] Subscribe to SignalR notifications
  - [ ] On status update for a report in the list:
    - Update status column without full page refresh
    - Show subtle animation/highlight for updated row
  - [ ] Unsubscribe on component destroy

### Testing Tasks

- [ ] **Task 20: Write unit tests for MockValidationService**
  - [ ] Test: `SubmitReportForValidation_ValidFile_ReturnsUniqueId`
  - [ ] Test: `GetValidationStatus_OngoingValidation_ReturnsProgress`
  - [ ] Test: `GetValidationResult_CompletedValidation_ReturnsResult`
  - [ ] Mock: IFileStorageService, ILogger

- [ ] **Task 21: Write unit tests for MockReportValidator**
  - [ ] Test: `ValidateReport_Q1File_PassesValidation` (test business rule)
  - [ ] Test: `ValidateReport_Q2File_FailsWithErrors` (test business rule)
  - [ ] Test: `ValidateReport_CorruptedFile_ThrowsException`
  - [ ] Test: `ValidateReport_MissingRequiredWorksheet_ReturnsErrors`
  - [ ] Use sample XLSX files

- [ ] **Task 22: Write unit tests for ReportValidatorWorker**
  - [ ] Test: `ProcessJob_ValidReport_UpdatesStatusToSuccessful`
  - [ ] Test: `ProcessJob_InvalidReport_UpdatesStatusToValidationErrors`
  - [ ] Test: `ProcessJob_TechnicalError_UpdatesStatusToTechnicalError`
  - [ ] Test: `ProcessJob_SendsNotificationOnCompletion`
  - [ ] Test: `ProcessJob_StoresResultPdf`
  - [ ] Test: `ProcessJob_RetriesOnTransientFailure`
  - [ ] Mock: IReportRepository, IValidationService, INotificationService

- [ ] **Task 23: Write unit tests for ValidationTimeoutWorker**
  - [ ] Test: `Run_ReportExceeds24Hours_UpdatesToTimeoutError`
  - [ ] Test: `Run_ReportWithin24Hours_NoAction`
  - [ ] Test: `Run_SendsNotificationOnTimeout`
  - [ ] Mock: IReportRepository, INotificationService

- [ ] **Task 24: Write integration test for validation workflow**
  - [ ] Test: `SubmitReport_ValidFile_CompletesValidationSuccessfully`
    - Submit report
    - Wait for validation to complete (or mock completion)
    - Verify status changed to Successful
    - Verify ValidationResult created
    - Verify result PDF stored
    - Verify notification sent
  - [ ] Test: `SubmitReport_InvalidFile_CompletesWithErrors`
    - Submit report with Q2 (fail test file)
    - Verify status changed to ValidationErrors
    - Verify errors stored
  - [ ] Test: `ValidationTimeout_24HoursPassed_UpdatesToTimeoutError`
    - Submit report
    - Manually set ValidationStartedDate to 25 hours ago
    - Run timeout worker
    - Verify status changed to TimeoutError
  - [ ] Use Testcontainers for database and RabbitMQ
  - [ ] Use in-memory RabbitMQ or mock

- [ ] **Task 25: Write E2E test for validation flow**
  - [ ] Test workflow:
    1. Login as external user
    2. Submit report (Q1 test file)
    3. Wait for status to change to "Transmitted"
    4. Wait for status to change to "Ongoing"
    5. Wait for status to change to "Successful" (max 15 seconds)
    6. Verify success notification displayed
    7. Navigate to report details
    8. Verify validation result PDF available for download
  - [ ] Use Cypress or Playwright
  - [ ] Mock or use actual validation worker

---

## Dev Notes

### Previous Story Context

**From Story 4.1:**
- Report submission creates Report entity with status "Working"
- File uploaded to blob storage
- ReportSubmittedEvent published
- This story implements the validation workflow triggered by that event

**Key Integration:**
- This story creates the async validation pipeline
- Results are displayed in Story 4.3
- Report list (Stories 4.5, 4.6) shows real-time status updates

### Architecture Context

**Source:** `docs/architecture/section-3-tech-stack.md`

**Backend Stack:**
- Language: C# 12.0
- Runtime: .NET 8.0 LTS
- Message Queue: RabbitMQ 3.13 with MassTransit 8.2
- Excel Parsing: ClosedXML 0.104.0
- PDF Generation: QuestPDF 2024.3.0
- Real-time: SignalR (ASP.NET Core SignalR)
- Background Jobs: MassTransit consumers (or Hangfire for scheduled tasks)
- Logging: Serilog 3.1.1

**Frontend Stack:**
- Real-time Library: @microsoft/signalr 8.0.0
- Notifications: PrimeNG Toast component

### Project Structure

**Source:** `docs/architecture/section-10-source-tree.md`

Backend files location:
```
src/Backend/
├── Application/UknfPlatform.Application.Shared/Interfaces/
│   └── IValidationService.cs (CREATE)
├── Infrastructure/UknfPlatform.Infrastructure.Validation/
│   ├── Services/
│   │   ├── MockValidationService.cs (CREATE)
│   │   ├── MockReportValidator.cs (CREATE)
│   │   └── ValidationResultPdfGenerator.cs (CREATE)
│   └── Configuration/
│       └── ValidationServiceConfiguration.cs (CREATE)
├── Workers/UknfPlatform.Workers.Validation/
│   ├── ReportValidatorWorker.cs (CREATE)
│   └── ValidationTimeoutWorker.cs (CREATE)
├── Domain/UknfPlatform.Domain.Communication/
│   ├── Entities/
│   │   ├── Report.cs (UPDATE - add validation methods)
│   │   └── ValidationResult.cs (CREATE)
│   └── Messages/
│       └── ReportValidationJob.cs (CREATE)
├── Api/UknfPlatform.Api/Hubs/
│   └── NotificationHub.cs (CREATE)
└── Infrastructure/UknfPlatform.Infrastructure.Persistence/
    └── Migrations/
        └── Add_ValidationResults_Table.cs (CREATE)
```

Frontend files location:
```
src/Frontend/uknf-platform-ui/src/app/
├── core/services/
│   └── notification-hub.service.ts (CREATE)
└── features/reporting/
    ├── report-details/ (UPDATE in Story 4.7)
    └── reports-list/ (UPDATE in Story 4.5)
```

### Core Workflow

**Source:** `docs/architecture/section-7-core-workflows.md`

**Validation Workflow Sequence:**
1. **Submit Report** (Story 4.1):
   - User uploads XLSX file
   - Report created with status "Working"
   - File stored in blob storage

2. **Transmit for Validation** (This Story):
   - Status: Working → Transmitted
   - ReportValidationJob published to RabbitMQ
   - UniqueValidationId generated

3. **Background Processing**:
   - Worker consumes job from queue
   - Status: Transmitted → Ongoing
   - Real-time update sent via SignalR

4. **Validation Execution**:
   - Download file from storage
   - Parse XLSX with ClosedXML
   - Apply validation rules
   - Generate result PDF with QuestPDF

5. **Completion**:
   - Status: Ongoing → (Successful | ValidationErrors | TechnicalError)
   - Store ValidationResult entity
   - Store result PDF
   - Send notifications (email + SignalR)

6. **Timeout Protection**:
   - Separate worker checks for validations > 24 hours
   - Auto-update to TimeoutError

### External Validation Service (Mock)

**Source:** `docs/architecture/section-6-external-apis.md`

**IMPORTANT:** For the hackathon demo, the "external" validation service is actually a **self-hosted mock** within our system.

**Mock Implementation Details:**
- **Not a real external API** - internal service
- Async processing via RabbitMQ workers
- Simulates 5-10 second processing delay (configurable)
- Uses test file business rule:
  * Files with "Q1" in reporting period → pass validation
  * Files with "Q2" in reporting period → fail with validation errors
- Parses XLSX with ClosedXML
- Generates PDF result with QuestPDF (mimics UKNF format)
- Can be easily replaced with real API later by implementing Refit interface

**Why Mock?**
- No access to actual UKNF validation service
- Allows us to control test scenarios
- Demonstrates full async workflow
- Shows all PRD-required validation statuses
- Zero external dependencies

### Data Models

**Source:** `docs/architecture/section-4-data-models.md`, `docs/architecture/section-9-database-schema.md`

**Report Entity (Update):**
- Add domain methods for status transitions
- ValidationStatus enum: Working, Transmitted, Ongoing, Successful, ValidationErrors, TechnicalError, TimeoutError, ContestedByUKNF
- UniqueValidationId from validation service
- ValidationStartedDate, ValidationCompletedDate timestamps
- ValidationResultFileKey for result PDF

**ValidationResult Entity (New):**
- Stores detailed validation results
- JSON fields for Errors[], Warnings[], ExtractedMetadata
- Links to Report (one-to-one or one-to-many)
- Separate table for historical tracking

### Validation Statuses

**Source:** `docs/prd/epic-4-reporting-system.md`

| Status | Description | Trigger |
|--------|-------------|---------|
| **Working** | After upload, before transmission | Story 4.1 |
| **Transmitted** | Sent to validation service | This story - AC 2 |
| **Ongoing** | Validation in progress | This story - AC 4 |
| **Successful** | No errors found | This story - AC 8 |
| **ValidationErrors** | Errors detected | This story - AC 8 |
| **TechnicalError** | Processing error | This story - AC 6, 8 |
| **TimeoutError** | > 24 hours | This story - AC 7 |
| **ContestedByUKNF** | Manually challenged | Story 4.10 |

### Coding Standards

**Source:** `docs/architecture/section-13-coding-standards.md`

**CRITICAL RULES:**

1. **State machine for status transitions**
   ```csharp
   // ✅ CORRECT - Use domain method
   report.TransmitForValidation(validationId);
   report.StartValidation();
   report.CompleteValidation(isValid, errors, resultFileKey);
   
   // ❌ WRONG - Direct property assignment
   // report.ValidationStatus = ValidationStatus.Ongoing;
   ```

2. **Async processing must not block API**
   ```csharp
   // ✅ CORRECT - Fire and forget via message queue
   await _messageBus.PublishAsync(new ReportValidationJob(...));
   return Ok(new { reportId, status = "Transmitted" });
   
   // ❌ WRONG - Synchronous validation
   // var result = await _validationService.ValidateReportAsync(...); // Don't wait!
   ```

3. **Handle transient failures with retry**
   ```csharp
   // ✅ CORRECT - Retry with exponential backoff
   var policy = Policy
       .Handle<HttpRequestException>()
       .WaitAndRetryAsync(3, retryAttempt => 
           TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)));
   
   await policy.ExecuteAsync(async () => 
       await _validationService.SubmitReportForValidationAsync(...));
   ```

4. **Use correlation ID for workflow tracing**
   ```csharp
   // ✅ CORRECT - Track across services
   using (_logger.BeginScope(new Dictionary<string, object>
   {
       ["CorrelationId"] = correlationId,
       ["ReportId"] = reportId
   }))
   {
       _logger.LogInformation("Validation started");
       // ... validation logic
   }
   ```

5. **Never expose internal errors to users**
   ```csharp
   // ✅ CORRECT - Generic message
   report.MarkAsTechnicalError("Validation service unavailable. Please try again later.");
   
   // ❌ WRONG - Expose stack trace
   // report.ErrorDescription = exception.ToString();
   ```

### RabbitMQ Configuration

**Queue:** `report-validation-queue`
**Exchange:** Default (direct)
**Message Type:** `ReportValidationJob`
**TTL:** 24 hours (86400000 ms)
**Prefetch:** 5 messages
**Concurrency:** 5 workers
**Retry Policy:** 3 retries with exponential backoff

**MassTransit Setup:**
```csharp
x.UsingRabbitMq((context, cfg) =>
{
    cfg.Host("rabbitmq", "/", h =>
    {
        h.Username("guest");
        h.Password("guest");
    });
    
    cfg.ReceiveEndpoint("report-validation-queue", e =>
    {
        e.ConfigureConsumer<ReportValidatorWorker>(context);
        e.PrefetchCount = 5;
        e.UseConcurrencyLimit(5);
        
        // Retry policy
        e.UseMessageRetry(r => r.Exponential(
            retryLimit: 3,
            minInterval: TimeSpan.FromSeconds(1),
            maxInterval: TimeSpan.FromSeconds(30),
            intervalDelta: TimeSpan.FromSeconds(2)));
        
        // Message TTL
        e.SetQueueArgument("x-message-ttl", 86400000); // 24 hours
    });
});
```

### SignalR Real-time Updates

**Hub:** `/hubs/notifications`
**Authentication:** JWT Bearer token required
**Methods:**
- Server→Client: `ReceiveReportStatusUpdate(reportId, status, message)`

**Frontend Connection:**
```typescript
const connection = new signalR.HubConnectionBuilder()
  .withUrl('/hubs/notifications', {
    accessTokenFactory: () => this.authService.getToken()
  })
  .withAutomaticReconnect()
  .build();

connection.on('ReceiveReportStatusUpdate', (reportId: string, status: string, message: string) => {
  this.updateReportStatus(reportId, status);
  this.notificationService.showInfo(message);
});

await connection.start();
```

### Mock Validation Business Rules

**Test File Rules (from PRD):**
- **G. RIP100000_Q1_2025.xlsx** → Pass validation (Successful)
- **G. RIP100000_Q2_2025.xlsx** → Fail validation (ValidationErrors)

**Validation Rules to Implement:**
1. **File Structure:**
   - Must be valid XLSX (ZIP archive with XML)
   - Must contain at least one worksheet
   - Worksheet names should match expected pattern

2. **Q1 Files (Pass):**
   - All required worksheets present
   - No missing mandatory fields
   - Data types correct
   - Return status: "Successful"

3. **Q2 Files (Fail):**
   - Simulate errors:
     * "Missing required field: 'Total Assets' in row 5"
     * "Invalid data type: Expected number, found text in cell C12"
     * "Sum validation failed: Column totals don't match"
   - Return status: "ValidationErrors"

4. **Processing Delay:**
   - Simulate async processing: `await Task.Delay(TimeSpan.FromSeconds(5))`
   - Make it configurable via appsettings.json

### Validation Result PDF Format

**Source:** PRD - validation result file should include:
- UKNF logo and official markings
- Report file name
- Receipt date (submission timestamp)
- Validation date (completion timestamp)
- Entity name and UKNF code
- Validation status (clear visual indicator)
- **If Successful:**
  - "Report validated successfully" message
  - List of checked items/rules
- **If Errors:**
  - List of errors with:
    * Error code/reference
    * Description
    * Location (worksheet, row, column)
    * Suggested correction

**QuestPDF Example:**
```csharp
Document.Create(container =>
{
    container.Page(page =>
    {
        page.Header().Text("UKNF Report Validation Result").FontSize(20).Bold();
        page.Content().Column(column =>
        {
            column.Item().Text($"Report: {reportName}");
            column.Item().Text($"Entity: {entityName}");
            column.Item().Text($"Validation Date: {validationDate}");
            column.Item().Text($"Status: {status}");
            
            if (errors.Any())
            {
                column.Item().Text("Errors:").Bold();
                foreach (var error in errors)
                {
                    column.Item().Text($"- {error.Description} (Location: {error.Location})");
                }
            }
        });
        page.Footer().Text($"Validation ID: {validationId}");
    });
}).GeneratePdf(stream);
```

### Error Handling Strategy

**Source:** `docs/architecture/section-12-error-handling-strategy.md`

**Transient Errors (Retry):**
- Network connection failures
- Blob storage timeouts
- Database deadlocks
- Action: Retry 3 times with exponential backoff

**Permanent Errors (Don't Retry):**
- Corrupted XLSX file
- Invalid file format
- Missing required data
- Action: Set status to ValidationErrors or TechnicalError

**Critical Errors (Alert):**
- RabbitMQ connection lost
- Database unavailable
- Action: Log critical error, notify ops team, retry later

### Performance Considerations

**Source:** `docs/prd/b-specification-of-non-functional-requirements.md#3-performance-and-scalability`

- Validation should not block API response (async via queue)
- Worker can process 5 reports concurrently (configurable)
- Large files (> 50 MB) may take longer - acceptable
- Timeout after 24 hours to prevent stuck jobs
- Use streaming for file operations (don't load entire file in memory)
- PDF generation should be efficient (< 2 seconds)

### Security Requirements

- Workers must validate report exists and user has access before processing
- Validation result PDF should not expose sensitive system details
- Errors shown to user should be sanitized (no stack traces)
- Only authenticated users receive SignalR updates for their own reports
- Audit all validation attempts and results

### Testing

**Source:** `docs/architecture/section-14-test-strategy-and-standards.md`

**Test Framework:** xUnit 2.6.6  
**Mocking:** Moq 4.20.70  
**Integration Tests:** Testcontainers 3.7.0 (PostgreSQL + RabbitMQ)

**Test Sample Files:**
- Create `G. RIP100000_Q1_2025.xlsx` - valid report (pass)
- Create `G. RIP100000_Q2_2025.xlsx` - invalid report (fail)
- Create corrupted XLSX file for error handling tests

**Example:**
```csharp
[Fact]
public async Task ProcessJob_Q1Report_UpdatesToSuccessful()
{
    // Arrange
    var job = new ReportValidationJob
    {
        ReportId = _reportId,
        FileName = "G. RIP100000_Q1_2025.xlsx",
        ReportingPeriod = "Q1_2025",
        // ...
    };
    
    // Act
    await _worker.ProcessJobAsync(job, CancellationToken.None);
    
    // Assert
    var report = await _reportRepository.GetByIdAsync(_reportId);
    report.ValidationStatus.Should().Be(ValidationStatus.Successful);
    report.ValidationCompletedDate.Should().NotBeNull();
    
    var validationResult = await _validationResultRepository.GetByReportIdAsync(_reportId);
    validationResult.IsValid.Should().BeTrue();
    validationResult.Errors.Should().BeEmpty();
    
    _notificationServiceMock.Verify(s => 
        s.SendEmailAsync(It.IsAny<string>(), It.Is<string>(subj => subj.Contains("Successful")), It.IsAny<string>()),
        Times.Once);
}
```

### Additional Notes

1. **Mock vs Real Service:** This story implements a mock validation service. To replace with real external API:
   - Create `ExternalValidationService.cs` implementing `IValidationService`
   - Use Refit to define HTTP client interface
   - Configure base URL and authentication
   - Swap implementation in DI container

2. **Validation Delay:** Mock validator simulates 5-10 second delay. Configure via:
   ```json
   "Validation": {
     "MockDelaySeconds": 7,
     "TimeoutHours": 24
   }
   ```

3. **Concurrency:** Worker can process 5 reports simultaneously. Increase if needed, but watch database connection pool.

4. **PDF Storage:** Validation result PDFs stored separately from report files. Consider lifecycle policy (auto-delete after 1 year).

5. **Status Polling (Alternative):** If SignalR not available, frontend can poll `GET /api/reports/{id}` every 5 seconds while status is "Ongoing".

6. **Idempotency:** Worker should be idempotent - if same job processed twice (e.g., after retry), result should be same.

7. **Audit Trail:** All validation attempts, retries, and results logged for compliance.

8. **Test Data:** Request actual report templates from stakeholders for realistic testing.

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Story created from Epic 4 | Scrum Master (AI) |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_This section will be populated by QA agent after story completion._

