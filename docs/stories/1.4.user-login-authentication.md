# Story 1.4: User Login (Authentication)

**Epic:** 1 - Authentication & User Registration  
**Story Number:** 1.4  
**Created:** 2025-10-04

---

## Status

**Draft**

---

## Story

**As an** external user with an active account,  
**I want to** log in using my email and password,  
**So that** I can access the communication platform.

---

## Acceptance Criteria

1. Login form accepts email address and password
2. System validates credentials against stored user data
3. Successful authentication creates a user session
4. Failed login attempts display generic error message (security best practice)
5. System implements rate limiting to prevent brute force attacks
6. System logs all authentication attempts (for audit purposes)
7. Successful login redirects to appropriate landing page based on user permissions

---

## Tasks / Subtasks

### Backend Tasks

- [ ] **Task 1: Create LoginCommand and Handler** (AC: 1, 2, 3, 7)
  - [ ] Create `LoginCommand.cs` in `Application/UknfPlatform.Application.Auth/Authentication/Commands/`
  - [ ] Command properties: Email (string), Password (string)
  - [ ] Create `LoginCommandHandler.cs`
  - [ ] Handler logic:
    - Find user by email
    - If user not found, throw generic `InvalidCredentialsException` (don't reveal user existence)
    - If user.IsActive == false, throw `AccountNotActivatedException`
    - Verify password using IPasswordHasher.VerifyPassword()
    - If password incorrect, throw generic `InvalidCredentialsException`
    - Check if password expired (user.LastPasswordChangeDate + PasswordExpirationDays < today)
    - If expired, return response indicating password change required
    - Generate JWT access token (via IJwtTokenService)
    - Generate refresh token (via IJwtTokenService)
    - Update user.LastLoginDate
    - Create user session record (if using session table)
    - Return LoginResponse with tokens and user info
  - [ ] Log successful login and failures (not password!)

- [ ] **Task 2: Create FluentValidation validator for LoginCommand** (AC: 1)
  - [ ] Create `LoginCommandValidator.cs`
  - [ ] Validate Email: NotEmpty, EmailAddress format
  - [ ] Validate Password: NotEmpty
  - [ ] Simple validation - detailed auth checks in handler

- [ ] **Task 3: Create JWT token service** (AC: 3)
  - [ ] Create `IJwtTokenService.cs` interface in `Application/UknfPlatform.Application.Shared/Interfaces/`
  - [ ] Methods: `GenerateAccessToken(user)`, `GenerateRefreshToken()`, `ValidateToken(token)`, `GetUserIdFromToken(token)`
  - [ ] Create `JwtTokenService.cs` implementation in `Infrastructure/UknfPlatform.Infrastructure.Identity/Services/`
  - [ ] Inject IOptions<JwtSettings> for configuration
  - [ ] Access token: Short-lived (15-60 minutes), contains user claims
  - [ ] Refresh token: Long-lived (7-30 days), stored in database for revocation
  - [ ] Use System.IdentityModel.Tokens.Jwt library
  - [ ] Sign tokens with secret key from configuration
  - [ ] Include claims: UserId, Email, UserType, Roles

- [ ] **Task 4: Create JWT settings configuration** (AC: 3)
  - [ ] Create `JwtSettings.cs` in `Infrastructure/UknfPlatform.Infrastructure.Identity/Settings/`
  - [ ] Properties: SecretKey, Issuer, Audience, AccessTokenExpirationMinutes, RefreshTokenExpirationDays
  - [ ] Map to appsettings.json `Jwt` section
  - [ ] Register in DI container via IOptions pattern
  - [ ] Document that SecretKey must be securely generated and stored

- [ ] **Task 5: Create RefreshToken entity** (AC: 3)
  - [ ] Create `RefreshToken.cs` in `Domain/UknfPlatform.Domain.Auth/Entities/`
  - [ ] Properties: Id (Guid), UserId (Guid FK), Token (string, unique), ExpiresAt (DateTime), IsRevoked (bool), CreatedDate, RevokedDate
  - [ ] Used for token refresh without re-authentication
  - [ ] Add index on Token and UserId

- [ ] **Task 6: Create database schema for RefreshTokens table** (AC: 3)
  - [ ] Create EF Core configuration `RefreshTokenConfiguration.cs`
  - [ ] Configure table, primary key, foreign key to Users
  - [ ] Add unique index on Token column
  - [ ] Add index on UserId and ExpiresAt
  - [ ] Create EF Core migration `Add_RefreshTokens_Table`

- [ ] **Task 7: Create LoginResponse DTO** (AC: 3, 7)
  - [ ] Create `LoginResponse.cs` record in `Application/UknfPlatform.Application.Auth/Authentication/Commands/`
  - [ ] Properties: AccessToken (string), RefreshToken (string), ExpiresIn (int seconds), User (UserInfoDto), RequiresPasswordChange (bool)
  - [ ] Create `UserInfoDto` record: UserId, Email, FirstName, LastName, UserType, Roles

- [ ] **Task 8: Create REST API endpoint POST /auth/login** (AC: All)
  - [ ] Add action to `AuthController.cs`: `LoginAsync(LoginCommand command)`
  - [ ] `[AllowAnonymous]` attribute
  - [ ] Send command via MediatR
  - [ ] Return 200 OK with LoginResponse on success
  - [ ] Return 401 Unauthorized with generic message on failure: "Invalid email or password"
  - [ ] Return 403 Forbidden if account not activated: "Please activate your account"
  - [ ] Return 403 Forbidden if password expired: "Password expired. Please reset your password."
  - [ ] Add Swagger documentation

- [ ] **Task 9: Implement rate limiting for login endpoint** (AC: 5)
  - [ ] Install AspNetCoreRateLimit NuGet package (or built-in .NET 7+ rate limiting)
  - [ ] Configure rate limiting in Program.cs
  - [ ] Limit: 5 failed attempts per IP per 15 minutes (configurable)
  - [ ] After limit reached, return 429 Too Many Requests
  - [ ] Log rate limit violations
  - [ ] Consider per-email rate limiting as well (more strict)

- [ ] **Task 10: Create audit logging for authentication** (AC: 6)
  - [ ] Create `AuthenticationAuditLog` entity
  - [ ] Properties: Id, UserId (nullable), Email, IpAddress, UserAgent, Action (Login/Logout/FailedLogin), Success (bool), FailureReason, Timestamp
  - [ ] Log in LoginCommandHandler for success and failure
  - [ ] Include IP address and User-Agent from HTTP context
  - [ ] Store in separate audit table for security monitoring
  - [ ] Add indexes on Timestamp, Email, Success for audit queries

- [ ] **Task 11: Create logout endpoint** (AC: 3)
  - [ ] Create POST `/auth/logout` endpoint
  - [ ] `[Authorize]` attribute (requires authenticated user)
  - [ ] Revoke refresh token (mark as revoked in database)
  - [ ] Invalidate access token (add to blacklist or rely on expiration)
  - [ ] Clear any server-side session
  - [ ] Return 204 No Content
  - [ ] Log logout event

- [ ] **Task 12: Configure JWT authentication in Program.cs** (AC: 3)
  - [ ] Add JWT bearer authentication middleware
  - [ ] Configure token validation parameters (issuer, audience, signing key)
  - [ ] Set ClockSkew to reduce token lifetime issues
  - [ ] Configure authentication scheme as default
  - [ ] Add authorization middleware
  - [ ] Ensure authentication runs before authorization

- [ ] **Task 13: Create token refresh endpoint** (AC: 3)
  - [ ] Create POST `/auth/refresh-token` endpoint
  - [ ] Request body: { refreshToken: string }
  - [ ] `[AllowAnonymous]` (user may have expired access token)
  - [ ] Validate refresh token exists and not expired/revoked
  - [ ] Generate new access token
  - [ ] Optionally rotate refresh token (security best practice)
  - [ ] Return new LoginResponse with tokens
  - [ ] Log token refresh

### Frontend Tasks

- [ ] **Task 14: Create login page component** (AC: 1, 4, 7)
  - [ ] Create `src/Frontend/uknf-platform-ui/src/app/features/auth/login/login.component.ts`
  - [ ] Standalone Angular component
  - [ ] Configure routing: `/auth/login` (public, no auth required)
  - [ ] Create reactive form with email and password fields

- [ ] **Task 15: Implement login form** (AC: 1)
  - [ ] Create reactive form with FormBuilder
  - [ ] Form fields:
    - email (email input, required, email format)
    - password (password input, required)
    - rememberMe (checkbox, optional - for persistent login)
  - [ ] Add validators:
    - email: Validators.required, Validators.email
    - password: Validators.required
  - [ ] Show/Hide password toggle
  - [ ] Display validation errors

- [ ] **Task 16: Add login method to AuthService** (AC: 2, 3)
  - [ ] Add method `login(email, password): Observable<LoginResponse>`
  - [ ] Call POST `/api/auth/login`
  - [ ] On success:
    - Store access token in memory or localStorage (based on security policy)
    - Store refresh token in httpOnly cookie or secure storage
    - Store user info in state management (e.g., signal, BehaviorSubject)
    - Set authentication state to true
  - [ ] Handle errors:
    - 401: Invalid credentials
    - 403: Account not activated or password expired
    - 429: Too many attempts
  - [ ] Use catchError for error handling

- [ ] **Task 17: Implement token storage strategy** (AC: 3)
  - [ ] Decision: localStorage vs sessionStorage vs memory
    - localStorage: Persistent across browser sessions (less secure)
    - sessionStorage: Only for current tab session (more secure)
    - Memory: Most secure but lost on page refresh
  - [ ] Recommendation: Store access token in memory with refresh token in httpOnly cookie
  - [ ] Create TokenStorageService to abstract storage mechanism
  - [ ] Implement getToken(), setToken(), removeToken() methods

- [ ] **Task 18: Create HTTP interceptor for JWT** (AC: 3)
  - [ ] Create `src/Frontend/.../core/interceptors/jwt.interceptor.ts`
  - [ ] Intercept all HTTP requests
  - [ ] Add Authorization header: `Bearer {accessToken}` to all requests (except auth endpoints)
  - [ ] Handle 401 responses (token expired):
    - Attempt token refresh using refresh token
    - Retry original request with new access token
    - If refresh fails, redirect to login
  - [ ] Register interceptor in app.config.ts

- [ ] **Task 19: Implement form submission logic** (AC: 4, 7)
  - [ ] On form submit:
    - Show loading spinner
    - Call authService.login(email, password)
    - On success (200):
      - Show success message (optional toast)
      - Redirect based on user type:
        - External users: Dashboard (entity selection if multiple entities - Story 2.10)
        - Internal users (UKNF): Admin dashboard
    - On error (401):
      - Display generic error: "Invalid email or password"
      - Don't reveal if email exists (security)
      - Clear password field
    - On error (403 Account Not Activated):
      - Display: "Please activate your account. Check your email."
      - Provide "Resend Activation" link
    - On error (403 Password Expired):
      - Display: "Your password has expired. Please reset it."
      - Redirect to password reset flow
    - On error (429):
      - Display: "Too many login attempts. Please try again in 15 minutes."
  - [ ] Disable submit button while loading

- [ ] **Task 20: Create login page UI** (AC: 1, 7)
  - [ ] Use auth-layout (centered form)
  - [ ] UKNF branding/logo
  - [ ] Page title: "Sign In"
  - [ ] Email input field
  - [ ] Password input field with show/hide toggle
  - [ ] "Remember me" checkbox (optional)
  - [ ] Submit button: "Sign In"
  - [ ] Links:
    - "Forgot Password?" (Story 1.7)
    - "Don't have an account? Register" (Story 1.1)
  - [ ] Error message display area
  - [ ] Style with Tailwind CSS
  - [ ] Responsive design
  - [ ] Loading state (spinner on button)

- [ ] **Task 21: Implement auto-login on token refresh** (AC: 3)
  - [ ] On app initialization (app.component.ts or auth.guard.ts):
    - Check if refresh token exists
    - If exists and valid, attempt to refresh access token
    - If successful, set user as authenticated
    - If failed, clear tokens and require login
  - [ ] Allows user to stay logged in across page refreshes

- [ ] **Task 22: Create logout functionality** (AC: 3)
  - [ ] Add logout method to AuthService
  - [ ] Call POST `/api/auth/logout`
  - [ ] Clear all tokens from storage
  - [ ] Clear user state
  - [ ] Redirect to login page
  - [ ] Handle logout button in main layout/header

- [ ] **Task 23: Create auth guard for protected routes** (AC: 3, 7)
  - [ ] Create `src/Frontend/.../core/guards/auth.guard.ts`
  - [ ] Check if user is authenticated (has valid access token)
  - [ ] If authenticated, allow navigation
  - [ ] If not authenticated, redirect to login with returnUrl
  - [ ] After login, redirect back to originally requested URL
  - [ ] Apply guard to all protected routes (dashboard, reports, etc.)

### Testing Tasks

- [ ] **Task 24: Write unit tests for LoginCommandHandler** (AC: 2, 3, 6)
  - [ ] Test: `Handle_ValidCredentials_ReturnsTokensAndUserInfo`
  - [ ] Test: `Handle_InvalidEmail_ThrowsInvalidCredentialsException`
  - [ ] Test: `Handle_InvalidPassword_ThrowsInvalidCredentialsException`
  - [ ] Test: `Handle_InactiveAccount_ThrowsAccountNotActivatedException`
  - [ ] Test: `Handle_ExpiredPassword_ReturnsRequiresPasswordChange`
  - [ ] Test: `Handle_ValidLogin_UpdatesLastLoginDate`
  - [ ] Test: `Handle_ValidLogin_LogsSuccessfulAuthentication`
  - [ ] Test: `Handle_FailedLogin_LogsFailedAttempt`
  - [ ] Mock: IUserRepository, IPasswordHasher, IJwtTokenService, IAuthenticationAuditLogRepository

- [ ] **Task 25: Write unit tests for JwtTokenService**
  - [ ] Test: `GenerateAccessToken_ValidUser_ReturnsTokenWithClaims`
  - [ ] Test: `GenerateRefreshToken_ReturnsSecureRandomToken`
  - [ ] Test: `ValidateToken_ValidToken_ReturnsTrue`
  - [ ] Test: `ValidateToken_ExpiredToken_ReturnsFalse`
  - [ ] Test: `GetUserIdFromToken_ValidToken_ReturnsUserId`

- [ ] **Task 26: Write integration tests for login flow** (AC: All)
  - [ ] Test: `POST_Login_WithValidCredentials_Returns200AndTokens`
  - [ ] Test: `POST_Login_WithInvalidPassword_Returns401`
  - [ ] Test: `POST_Login_WithNonExistentEmail_Returns401`
  - [ ] Test: `POST_Login_WithInactiveAccount_Returns403`
  - [ ] Test: `POST_Login_UpdatesLastLoginDate`
  - [ ] Test: `POST_Login_CreatesAuditLogEntry`
  - [ ] Test: `POST_Login_ExceedingRateLimit_Returns429`
  - [ ] Use Testcontainers for database
  - [ ] Verify tokens are valid JWT tokens
  - [ ] Verify password verification works correctly

- [ ] **Task 27: Write integration tests for token refresh**
  - [ ] Test: `POST_RefreshToken_WithValidToken_ReturnsNewAccessToken`
  - [ ] Test: `POST_RefreshToken_WithExpiredToken_Returns401`
  - [ ] Test: `POST_RefreshToken_WithRevokedToken_Returns401`

- [ ] **Task 28: Write E2E test for complete authentication flow**
  - [ ] Test complete workflow:
    1. Navigate to login page
    2. Enter valid credentials
    3. Submit form
    4. Verify redirect to dashboard
    5. Verify user is authenticated
    6. Navigate to protected page (verify access)
    7. Logout
    8. Verify redirect to login
    9. Verify cannot access protected page
  - [ ] Use Cypress or Playwright

- [ ] **Task 29: Write security tests**
  - [ ] Test: Rate limiting works (6th attempt fails)
  - [ ] Test: Generic error messages don't reveal user existence
  - [ ] Test: Password not logged in audit logs
  - [ ] Test: Tokens expire properly
  - [ ] Test: Refresh token revocation works

---

## Dev Notes

### Previous Story Context

**From Story 1.1:**
- User entity created with Email and PasswordHash fields
- Users can register

**From Story 1.2:**
- Account activation sets IsActive = true
- Users must activate before they can login

**From Story 1.3:**
- Password hashing service (IPasswordHasher) implemented
- User.PasswordHash populated
- User.LastPasswordChangeDate tracked
- Password policy configuration available

**Key Integration:**
- This story completes the authentication flow
- After login, users can access the platform
- Session/token management enables authorization (Epic 2)

### Architecture Context

**Tech Stack:**
- Backend: C# 12.0, .NET 8.0, ASP.NET Core, EF Core
- JWT: System.IdentityModel.Tokens.Jwt (version 7.0.0+)
- Rate Limiting: AspNetCoreRateLimit (version 5.0.0) or built-in .NET 7+
- Frontend: Angular 20, RxJS, HTTP Client

### Project Structure

Backend files:
```
src/Backend/
├── Api/UknfPlatform.Api/Controllers/
│   └── AuthController.cs (UPDATE: add login, logout, refresh-token)
├── Application/UknfPlatform.Application.Auth/Authentication/
│   ├── Commands/
│   │   ├── LoginCommand.cs (CREATE)
│   │   ├── LoginCommandHandler.cs (CREATE)
│   │   ├── LoginResponse.cs (CREATE)
│   │   └── Validators/
│   │       └── LoginCommandValidator.cs (CREATE)
├── Domain/UknfPlatform.Domain.Auth/
│   └── Entities/
│       ├── RefreshToken.cs (CREATE)
│       └── AuthenticationAuditLog.cs (CREATE)
├── Infrastructure/UknfPlatform.Infrastructure.Identity/
│   ├── Services/
│   │   ├── IJwtTokenService.cs (CREATE)
│   │   └── JwtTokenService.cs (CREATE)
│   └── Settings/
│       └── JwtSettings.cs (CREATE)
├── Infrastructure/UknfPlatform.Infrastructure.Persistence/
│   ├── Configurations/
│   │   ├── RefreshTokenConfiguration.cs (CREATE)
│   │   └── AuthenticationAuditLogConfiguration.cs (CREATE)
│   └── Repositories/
│       ├── RefreshTokenRepository.cs (CREATE)
│       └── AuthenticationAuditLogRepository.cs (CREATE)
```

Frontend files:
```
src/Frontend/uknf-platform-ui/src/app/
├── core/
│   ├── services/
│   │   ├── auth.service.ts (UPDATE: add login, logout, token refresh)
│   │   └── token-storage.service.ts (CREATE)
│   ├── guards/
│   │   └── auth.guard.ts (CREATE)
│   └── interceptors/
│       └── jwt.interceptor.ts (CREATE)
├── features/auth/login/
│   ├── login.component.ts (CREATE)
│   ├── login.component.html (CREATE)
│   └── login.component.scss (CREATE)
```

### Data Models

**RefreshTokens Table Schema:**
```sql
CREATE TABLE RefreshTokens (
    Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    UserId UUID NOT NULL,
    Token NVARCHAR(500) NOT NULL UNIQUE,
    ExpiresAt DATETIME2 NOT NULL,
    IsRevoked BIT NOT NULL DEFAULT 0,
    RevokedDate DATETIME2 NULL,
    CreatedDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    
    FOREIGN KEY (UserId) REFERENCES Users(Id) ON DELETE CASCADE,
    INDEX IX_RefreshTokens_Token (Token),
    INDEX IX_RefreshTokens_UserId_ExpiresAt (UserId, ExpiresAt)
);
```

**AuthenticationAuditLog Table Schema:**
```sql
CREATE TABLE AuthenticationAuditLog (
    Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    UserId UUID NULL,
    Email NVARCHAR(256) NOT NULL,
    IpAddress NVARCHAR(45) NOT NULL,
    UserAgent NVARCHAR(500) NULL,
    Action NVARCHAR(50) NOT NULL, -- Login, Logout, FailedLogin, TokenRefresh
    Success BIT NOT NULL,
    FailureReason NVARCHAR(200) NULL,
    Timestamp DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    
    FOREIGN KEY (UserId) REFERENCES Users(Id),
    INDEX IX_AuthenticationAuditLog_Timestamp (Timestamp),
    INDEX IX_AuthenticationAuditLog_Email (Email),
    INDEX IX_AuthenticationAuditLog_Success (Success)
);
```

### JWT Configuration

**JwtSettings (appsettings.json):**
```json
{
  "Jwt": {
    "SecretKey": "your-256-bit-secret-key-here-min-32-chars",
    "Issuer": "UknfCommunicationPlatform",
    "Audience": "UknfCommunicationPlatformUsers",
    "AccessTokenExpirationMinutes": 60,
    "RefreshTokenExpirationDays": 7
  }
}
```

**IMPORTANT:** SecretKey must be:
- At least 256 bits (32 characters)
- Securely generated (use `RandomNumberGenerator`)
- Stored securely (environment variables, Key Vault in production)
- NEVER committed to source control

**Generate Secret Key:**
```csharp
var key = new byte[32];
using (var rng = RandomNumberGenerator.Create())
{
    rng.GetBytes(key);
}
var secretKey = Convert.ToBase64String(key);
// Store in user secrets or environment variable
```

### JWT Token Implementation

**JwtTokenService Example:**
```csharp
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;

public class JwtTokenService : IJwtTokenService
{
    private readonly JwtSettings _jwtSettings;
    
    public JwtTokenService(IOptions<JwtSettings> jwtSettings)
    {
        _jwtSettings = jwtSettings.Value;
    }
    
    public string GenerateAccessToken(User user, IEnumerable<string> roles)
    {
        var claims = new List<Claim>
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Email, user.Email),
            new Claim("UserType", user.UserType.ToString()),
            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())
        };
        
        // Add roles as claims
        claims.AddRange(roles.Select(role => new Claim(ClaimTypes.Role, role)));
        
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtSettings.SecretKey));
        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        var token = new JwtSecurityToken(
            issuer: _jwtSettings.Issuer,
            audience: _jwtSettings.Audience,
            claims: claims,
            expires: DateTime.UtcNow.AddMinutes(_jwtSettings.AccessTokenExpirationMinutes),
            signingCredentials: credentials
        );
        
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
    
    public string GenerateRefreshToken()
    {
        var randomBytes = new byte[64];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(randomBytes);
        }
        return Convert.ToBase64String(randomBytes);
    }
    
    public bool ValidateToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var key = Encoding.UTF8.GetBytes(_jwtSettings.SecretKey);
        
        try
        {
            tokenHandler.ValidateToken(token, new TokenValidationParameters
            {
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = new SymmetricSecurityKey(key),
                ValidateIssuer = true,
                ValidIssuer = _jwtSettings.Issuer,
                ValidateAudience = true,
                ValidAudience = _jwtSettings.Audience,
                ValidateLifetime = true,
                ClockSkew = TimeSpan.Zero
            }, out SecurityToken validatedToken);
            
            return true;
        }
        catch
        {
            return false;
        }
    }
    
    public Guid GetUserIdFromToken(string token)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var jwtToken = tokenHandler.ReadJwtToken(token);
        var userIdClaim = jwtToken.Claims.First(c => c.Type == ClaimTypes.NameIdentifier);
        return Guid.Parse(userIdClaim.Value);
    }
}
```

### JWT Authentication Configuration (Program.cs)

```csharp
// Add JWT authentication
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    var jwtSettings = builder.Configuration.GetSection("Jwt").Get<JwtSettings>();
    
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuerSigningKey = true,
        IssuerSigningKey = new SymmetricSecurityKey(
            Encoding.UTF8.GetBytes(jwtSettings.SecretKey)),
        ValidateIssuer = true,
        ValidIssuer = jwtSettings.Issuer,
        ValidateAudience = true,
        ValidAudience = jwtSettings.Audience,
        ValidateLifetime = true,
        ClockSkew = TimeSpan.Zero // Reduce grace period
    };
    
    options.Events = new JwtBearerEvents
    {
        OnAuthenticationFailed = context =>
        {
            if (context.Exception is SecurityTokenExpiredException)
            {
                context.Response.Headers.Add("Token-Expired", "true");
            }
            return Task.CompletedTask;
        }
    };
});

builder.Services.AddAuthorization();

// Later in pipeline:
app.UseAuthentication();
app.UseAuthorization();
```

### Rate Limiting Configuration

**Using ASP.NET Core 7+ Rate Limiting:**
```csharp
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("login", limiterOptions =>
    {
        limiterOptions.PermitLimit = 5;
        limiterOptions.Window = TimeSpan.FromMinutes(15);
        limiterOptions.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;
        limiterOptions.QueueLimit = 0;
    });
});

// In controller:
[EnableRateLimiting("login")]
[HttpPost("login")]
public async Task<ActionResult<LoginResponse>> LoginAsync(LoginCommand command)
{
    // ...
}
```

### REST API Specification

**Endpoint 1:** POST `/api/auth/login`
- **Security:** None (public)
- **Request:**
  ```json
  {
    "email": "user@example.com",
    "password": "MyP@ssw0rd!"
  }
  ```
- **Success (200 OK):**
  ```json
  {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "base64-encoded-random-token",
    "expiresIn": 3600,
    "user": {
      "userId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "email": "user@example.com",
      "firstName": "Jan",
      "lastName": "Kowalski",
      "userType": "External"
    },
    "requiresPasswordChange": false
  }
  ```
- **Errors:**
  - 401: Invalid credentials
  - 403: Account not activated or password expired
  - 429: Too many attempts

**Endpoint 2:** POST `/api/auth/refresh-token`
- **Security:** None (public)
- **Request:**
  ```json
  {
    "refreshToken": "base64-encoded-token"
  }
  ```
- **Success (200 OK):**
  ```json
  {
    "accessToken": "new-jwt-token",
    "refreshToken": "new-refresh-token-if-rotated",
    "expiresIn": 3600
  }
  ```

**Endpoint 3:** POST `/api/auth/logout`
- **Security:** Requires authentication
- **Success:** 204 No Content

### Frontend Token Storage Strategy

**Option 1: Memory + HttpOnly Cookie (Most Secure - Recommended)**
```typescript
// Access token in memory
private accessToken: string | null = null;

// Refresh token in httpOnly cookie (set by backend)
// Backend sets: Set-Cookie: refreshToken=...; HttpOnly; Secure; SameSite=Strict
```

**Option 2: LocalStorage (Simple, Less Secure)**
```typescript
// Both tokens in localStorage
localStorage.setItem('accessToken', token);
localStorage.setItem('refreshToken', refreshToken);
```

**Recommendation:** Use Option 1 for production (most secure against XSS)

### Angular HTTP Interceptor

```typescript
import { HttpInterceptorFn } from '@angular/common/http';
import { inject } from '@angular/core';
import { AuthService } from '../services/auth.service';
import { catchError, switchMap } from 'rxjs/operators';
import { throwError } from 'rxjs';

export const jwtInterceptor: HttpInterceptorFn = (req, next) => {
  const authService = inject(AuthService);
  const token = authService.getAccessToken();
  
  // Don't add token to auth endpoints
  if (req.url.includes('/auth/')) {
    return next(req);
  }
  
  // Add Authorization header if token exists
  if (token) {
    req = req.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
  }
  
  return next(req).pipe(
    catchError(error => {
      // If 401 and token expired, try refresh
      if (error.status === 401 && error.headers.get('Token-Expired')) {
        return authService.refreshToken().pipe(
          switchMap(() => {
            // Retry original request with new token
            const newToken = authService.getAccessToken();
            req = req.clone({
              setHeaders: {
                Authorization: `Bearer ${newToken}`
              }
            });
            return next(req);
          }),
          catchError(refreshError => {
            // Refresh failed, logout user
            authService.logout();
            return throwError(() => refreshError);
          })
        );
      }
      
      return throwError(() => error);
    })
  );
};
```

### Coding Standards (Key Points)

1. **Never Log Passwords:**
   ```csharp
   // ❌ WRONG
   _logger.LogInformation("Login attempt: {Email} {Password}", email, password);
   
   // ✅ CORRECT
   _logger.LogInformation("Login attempt for email {Email}", email);
   ```

2. **Generic Error Messages:**
   ```csharp
   // ✅ CORRECT - Don't reveal if email exists
   throw new InvalidCredentialsException("Invalid email or password");
   ```

3. **Rate Limiting:**
   - Apply to login endpoint
   - Log rate limit violations
   - Consider IP-based and email-based limits

4. **JWT Token Security:**
   - Use strong secret key (256+ bits)
   - Set appropriate expiration times
   - Validate issuer, audience, lifetime
   - Set ClockSkew to TimeSpan.Zero

5. **Refresh Token Security:**
   - Store in database for revocation
   - Single-use (optional: rotate on refresh)
   - Long expiration (7-30 days)
   - Revoke on logout

### Security Requirements

1. **Password Verification:** Use IPasswordHasher from Story 1.3 (constant-time comparison)
2. **Rate Limiting:** 5 attempts per 15 minutes per IP
3. **JWT Secret:** 256-bit minimum, securely stored
4. **Token Expiration:** Access token short-lived (15-60 min), refresh token longer (7-30 days)
5. **Audit Logging:** All auth attempts logged (success and failure)
6. **Generic Errors:** Don't reveal user existence
7. **HTTPS:** Required for production
8. **Token Revocation:** Support logout via refresh token revocation

### Audit Requirements

**Log for Each Login Attempt:**
- UserId (if found)
- Email (attempted)
- IP Address
- User-Agent
- Action (Login/FailedLogin)
- Success (true/false)
- FailureReason (if failed)
- Timestamp

**Use for:**
- Security monitoring
- Suspicious activity detection
- Compliance reporting
- Brute force attack detection

### Dependencies

**Prerequisites:**
- Story 1.1: User entity
- Story 1.2: IsActive check
- Story 1.3: PasswordHasher, password stored

**Blocks:**
- Epic 2: Authorization (needs authenticated users)
- All other epics (require authentication)

### Testing Strategy

**Unit Tests:**
- LoginCommandHandler (all scenarios)
- JwtTokenService (token generation, validation)
- Rate limiting logic

**Integration Tests:**
- Full login flow with database
- Token generation and validation
- Rate limiting enforcement
- Audit logging

**Security Tests:**
- Rate limiting works
- Generic error messages
- Token expiration
- Refresh token revocation

**E2E Tests:**
- Complete auth flow: Login → Access protected page → Logout

### Common Error Scenarios

1. **Invalid credentials:** 401 with "Invalid email or password"
2. **Account not activated:** 403 with "Please activate your account"
3. **Password expired:** 403 with "Password expired"
4. **Too many attempts:** 429 with "Too many attempts"
5. **Token expired:** 401 with Token-Expired header (trigger refresh)
6. **Invalid token:** 401 (logout user)

### Additional Notes

1. **Remember Me:** If implemented, extend refresh token expiration
2. **Multi-Device Login:** Allowed (multiple refresh tokens per user)
3. **Token Rotation:** Optional security enhancement (rotate refresh token on each use)
4. **Blacklist vs Expiration:** Rely on token expiration, use refresh token revocation for logout
5. **ClockSkew:** Set to TimeSpan.Zero to enforce exact expiration times

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Story created from Epic 1 | Product Owner |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_This section will be populated by QA agent after story completion._

