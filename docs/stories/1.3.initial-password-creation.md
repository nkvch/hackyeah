# Story 1.3: Initial Password Creation

**Epic:** 1 - Authentication & User Registration  
**Story Number:** 1.3  
**Created:** 2025-10-04

---

## Status

**Draft**

---

## Story

**As an** external user activating my account,  
**I want to** set my initial password according to system policy,  
**so that** I can secure my account and log in.

---

## Acceptance Criteria

1. Password creation form enforces system password policy (complexity, length, uniqueness requirements)
2. Password strength indicator is displayed to the user
3. Password confirmation field requires exact match
4. System validates password meets all policy requirements before accepting
5. Upon successful password creation, account status changes to "Active"
6. System displays success message and redirects to login page
7. Password is securely hashed before storage

---

## Tasks / Subtasks

### Backend Tasks

- [ ] **Task 1: Create PasswordPolicy configuration entity** (AC: 1, 4)
  - [ ] Create `PasswordPolicy.cs` value object in `Domain/UknfPlatform.Domain.Shared/ValueObjects/`
  - [ ] Properties: MinLength, RequireUppercase, RequireLowercase, RequireDigit, RequireSpecialChar, MinUniqueChars
  - [ ] Add validation method `Validate(password)` returning validation result
  - [ ] Add method `GetStrengthScore(password)` for password strength calculation
  - [ ] Default policy: MinLength=8, RequireUppercase=true, RequireLowercase=true, RequireDigit=true, RequireSpecialChar=true

- [ ] **Task 2: Create PasswordPolicy configuration in settings** (AC: 1)
  - [ ] Create `PasswordPolicySettings.cs` in `Application/UknfPlatform.Application.Shared/Settings/`
  - [ ] Map to appsettings.json `PasswordPolicy` section
  - [ ] Make configurable: MinLength, RequireUppercase, RequireLowercase, RequireDigit, RequireSpecialChar, PasswordHistoryCount, PasswordExpirationDays
  - [ ] Register in DI container via IOptions pattern

- [ ] **Task 3: Create password hashing service** (AC: 7)
  - [ ] Create `IPasswordHasher.cs` interface in `Application/UknfPlatform.Application.Shared/Interfaces/`
  - [ ] Methods: `HashPassword(password)`, `VerifyPassword(password, hash)`
  - [ ] Create `PasswordHasher.cs` implementation in `Infrastructure/UknfPlatform.Infrastructure.Identity/Services/`
  - [ ] Use Argon2 or BCrypt algorithm (Argon2 recommended for new systems)
  - [ ] Configure work factor/iterations for security vs performance balance
  - [ ] Salt passwords automatically (built into Argon2/BCrypt)
  - [ ] Log hashing operations (not password values!)

- [ ] **Task 4: Create PasswordHistory entity** (AC: 4)
  - [ ] Create `PasswordHistory.cs` in `Domain/UknfPlatform.Domain.Auth/Entities/`
  - [ ] Properties: Id (Guid), UserId (Guid FK), PasswordHash (string), CreatedDate (DateTime)
  - [ ] Used to prevent password reuse (configured by PasswordHistoryCount)
  - [ ] Add index on UserId for efficient lookups

- [ ] **Task 5: Create database schema for PasswordHistory table** (AC: 4)
  - [ ] Create EF Core configuration `PasswordHistoryConfiguration.cs`
  - [ ] Configure table, primary key, foreign key to Users
  - [ ] Add index on UserId and CreatedDate
  - [ ] Create EF Core migration `Add_PasswordHistory_Table`

- [ ] **Task 6: Create SetPasswordCommand and Handler** (AC: All)
  - [ ] Create `SetPasswordCommand.cs` in `Application/UknfPlatform.Application.Auth/Authentication/Commands/`
  - [ ] Command properties: Token (string, from activation), Password (string), PasswordConfirmation (string)
  - [ ] Create `SetPasswordCommandHandler.cs`
  - [ ] Handler logic:
    - Validate token is valid (not expired, not used) - reuse activation token
    - Get user from token
    - Validate password meets policy requirements
    - Check password not in history (if PasswordHistoryCount > 0)
    - Hash password using IPasswordHasher
    - Update user.PasswordHash
    - Set user.IsActive = true (if not already)
    - Set user.MustChangePassword = false
    - Mark activation token as used
    - Add entry to PasswordHistory
    - Save changes
    - Return success response with userId
  - [ ] Log password setting (not password value!)

- [ ] **Task 7: Create FluentValidation validator for SetPasswordCommand** (AC: 1, 3, 4)
  - [ ] Create `SetPasswordCommandValidator.cs`
  - [ ] Validate Token: NotEmpty
  - [ ] Validate Password: NotEmpty, inject PasswordPolicy and validate against it
  - [ ] Validate PasswordConfirmation: Equal to Password
  - [ ] Custom validator: Check password complexity (uppercase, lowercase, digit, special char)
  - [ ] Custom validator: Check minimum length
  - [ ] Return detailed validation messages for each policy violation

- [ ] **Task 8: Create SetPasswordResponse DTO** (AC: 6)
  - [ ] Create `SetPasswordResponse.cs` record
  - [ ] Properties: UserId (Guid), Message (string), RedirectUrl (string to login page)

- [ ] **Task 9: Create REST API endpoint POST /auth/set-password** (AC: All)
  - [ ] Add action to `AuthController.cs`: `SetPasswordAsync(SetPasswordCommand command)`
  - [ ] `[AllowAnonymous]` attribute (user not authenticated yet)
  - [ ] Send command via MediatR
  - [ ] Return 200 OK with success message
  - [ ] Return 400 Bad Request with validation errors
  - [ ] Return 400 Bad Request if token expired/invalid
  - [ ] Success message: "Password set successfully. You can now log in."
  - [ ] Add Swagger documentation

- [ ] **Task 10: Create password strength calculation service** (AC: 2)
  - [ ] Create `IPasswordStrengthCalculator.cs` interface
  - [ ] Create `PasswordStrengthCalculator.cs` implementation
  - [ ] Calculate strength score (0-100) based on:
    - Length (longer = stronger)
    - Character diversity (uppercase, lowercase, digits, special chars)
    - No common patterns (123456, qwerty, etc.)
    - No dictionary words
  - [ ] Return strength level: Weak (0-40), Fair (41-60), Good (61-80), Strong (81-100)
  - [ ] Used by both backend validation and frontend indicator

- [ ] **Task 11: Create GET /auth/password-policy endpoint** (AC: 1, 2)
  - [ ] Create endpoint to retrieve current password policy
  - [ ] `[AllowAnonymous]` (needed for frontend to know requirements)
  - [ ] Return policy configuration (min length, requirements, etc.)
  - [ ] Frontend will use this to show requirements and validate client-side
  - [ ] Response: `{ "minLength": 8, "requireUppercase": true, ... }`

- [ ] **Task 12: Update User entity with password hash field** (AC: 7)
  - [ ] Ensure User.PasswordHash property exists (should be from Story 1.1)
  - [ ] Update User entity to include LastPasswordChangeDate
  - [ ] Add domain method SetPassword(passwordHash) to encapsulate password setting
  - [ ] Update EF Core migration if needed

### Frontend Tasks

- [ ] **Task 13: Create set password page component** (AC: 1, 2, 3, 6)
  - [ ] Create `src/Frontend/uknf-platform-ui/src/app/features/auth/set-password/set-password.component.ts`
  - [ ] Standalone Angular component
  - [ ] Configure routing: `/auth/set-password?token={token}` (no auth required)
  - [ ] Extract token from query parameters

- [ ] **Task 14: Implement set password form** (AC: 1, 2, 3)
  - [ ] Create reactive form with FormBuilder
  - [ ] Form fields:
    - password (password input)
    - passwordConfirmation (password input)
  - [ ] Add validators:
    - password: Validators.required, custom async validator (calls backend policy)
    - passwordConfirmation: Validators.required, matchPassword custom validator
  - [ ] Implement "Show/Hide Password" toggle buttons
  - [ ] Display validation errors below fields

- [ ] **Task 15: Implement password strength indicator** (AC: 2)
  - [ ] Create password strength bar component (reusable)
  - [ ] Show visual indicator: progress bar or color-coded meter
  - [ ] Display strength level: Weak, Fair, Good, Strong
  - [ ] Update in real-time as user types
  - [ ] Call password strength API or calculate client-side
  - [ ] Colors: Red (Weak), Orange (Fair), Yellow (Good), Green (Strong)
  - [ ] Show specific feedback: "Add uppercase letters", "Add numbers", etc.

- [ ] **Task 16: Display password policy requirements** (AC: 1)
  - [ ] Fetch password policy from GET /auth/password-policy on component init
  - [ ] Display requirements checklist:
    - ✓ At least 8 characters
    - ✓ Contains uppercase letter
    - ✓ Contains lowercase letter
    - ✓ Contains digit
    - ✓ Contains special character
  - [ ] Check items dynamically as user types
  - [ ] Use green checkmarks for met requirements, gray for unmet

- [ ] **Task 17: Add setPassword method to AuthService** (AC: All)
  - [ ] Add method `setPassword(token, password, passwordConfirmation): Observable<SetPasswordResponse>`
  - [ ] Call POST `/api/auth/set-password`
  - [ ] Handle response and errors

- [ ] **Task 18: Implement form submission logic** (AC: 6)
  - [ ] On form submit:
    - Show loading spinner
    - Call authService.setPassword(token, password, passwordConfirmation)
    - On success (200):
      - Show success message: "Password set successfully!"
      - Redirect to login page after 2 seconds
    - On error (400):
      - Display validation errors
      - If token expired: "Activation link has expired. Please request a new one."
      - If password too weak: Show specific policy violations
  - [ ] Disable submit button while loading or form invalid

- [ ] **Task 19: Create set password page UI** (AC: 1, 2, 3, 6)
  - [ ] Use auth-layout (centered form)
  - [ ] UKNF branding/logo
  - [ ] Page title: "Set Your Password"
  - [ ] Instructions: "Choose a strong password to secure your account"
  - [ ] Password policy requirements checklist
  - [ ] Password input field with show/hide toggle
  - [ ] Password strength indicator
  - [ ] Confirm password field
  - [ ] Submit button: "Set Password"
  - [ ] Success state: checkmark, message, countdown to login redirect
  - [ ] Style with Tailwind CSS
  - [ ] Responsive design

- [ ] **Task 20: Create reusable password strength component** (AC: 2)
  - [ ] Create `src/Frontend/.../shared/components/password-strength/password-strength.component.ts`
  - [ ] Input: password value
  - [ ] Output: displays strength meter
  - [ ] Can be reused in password change (Story 1.6) and password reset (Story 1.7)

### Testing Tasks

- [ ] **Task 21: Write unit tests for SetPasswordCommandHandler** (AC: All)
  - [ ] Test: `Handle_ValidPasswordAndToken_SetsPasswordSuccessfully`
  - [ ] Test: `Handle_InvalidToken_ThrowsInvalidTokenException`
  - [ ] Test: `Handle_ExpiredToken_ThrowsTokenExpiredException`
  - [ ] Test: `Handle_PasswordTooShort_ThrowsValidationException`
  - [ ] Test: `Handle_PasswordMissingUppercase_ThrowsValidationException`
  - [ ] Test: `Handle_PasswordInHistory_ThrowsValidationException`
  - [ ] Test: `Handle_PasswordConfirmationMismatch_ThrowsValidationException`
  - [ ] Test: `Handle_ValidPassword_HashesBeforeStorage`
  - [ ] Test: `Handle_ValidPassword_AddsToPasswordHistory`
  - [ ] Mock: IActivationTokenRepository, IUserRepository, IPasswordHasher, IPasswordHistoryRepository

- [ ] **Task 22: Write unit tests for PasswordHasher**
  - [ ] Test: `HashPassword_ValidPassword_ReturnsHashedPassword`
  - [ ] Test: `HashPassword_SamePassword_ReturnsDifferentHashes` (due to random salt)
  - [ ] Test: `VerifyPassword_CorrectPassword_ReturnsTrue`
  - [ ] Test: `VerifyPassword_IncorrectPassword_ReturnsFalse`

- [ ] **Task 23: Write unit tests for PasswordPolicy validation**
  - [ ] Test: `Validate_PasswordMeetsAllRequirements_ReturnsValid`
  - [ ] Test: `Validate_PasswordTooShort_ReturnsInvalid`
  - [ ] Test: `Validate_PasswordMissingUppercase_ReturnsInvalid`
  - [ ] Test: `Validate_PasswordMissingDigit_ReturnsInvalid`
  - [ ] Test each policy rule independently

- [ ] **Task 24: Write integration tests for set password flow** (AC: All)
  - [ ] Test: `POST_SetPassword_WithValidTokenAndPassword_Returns200`
  - [ ] Test: `POST_SetPassword_WithWeakPassword_Returns400`
  - [ ] Test: `POST_SetPassword_WithExpiredToken_Returns400`
  - [ ] Test: `POST_SetPassword_WithPasswordInHistory_Returns400`
  - [ ] Verify password is hashed in database (not plaintext)
  - [ ] Verify user.IsActive = true after setting password
  - [ ] Use Testcontainers for database

- [ ] **Task 25: Write E2E test for registration to login flow**
  - [ ] Test complete workflow:
    1. Register new user
    2. Activate account via email link
    3. Set password
    4. Verify redirect to login
    5. (Verify can login - Story 1.4)
  - [ ] Use Cypress or Playwright

---

## Dev Notes

### Previous Story Context

**From Story 1.1:**
- User entity created with PasswordHash field (initially empty)
- User.IsActive defaults to false for new registrations

**From Story 1.2:**
- ActivationToken entity created with 24-hour expiration
- Account activation sets user.IsActive = true (optional, can also be done in this story)
- Activation flow redirects to password creation (this story)

**Key Integration Points:**
- Reuse activation token from Story 1.2 to validate user identity
- After password is set, mark activation token as used (prevent reuse)
- User is fully ready to login after this story completes

### Architecture Context

**Tech Stack (same as previous stories):**
- Backend: C# 12.0, .NET 8.0, ASP.NET Core, EF Core, PostgreSQL
- Password Hashing: Argon2 (recommended) or BCrypt
- Frontend: Angular 20, PrimeNG, Tailwind CSS

### Project Structure

Backend files:
```
src/Backend/
├── Api/UknfPlatform.Api/Controllers/
│   └── AuthController.cs (UPDATE: add set-password endpoints)
├── Application/UknfPlatform.Application.Auth/Authentication/
│   ├── Commands/
│   │   ├── SetPasswordCommand.cs (CREATE)
│   │   ├── SetPasswordCommandHandler.cs (CREATE)
│   │   └── Validators/
│   │       └── SetPasswordCommandValidator.cs (CREATE)
│   └── Queries/
│       ├── GetPasswordPolicyQuery.cs (CREATE)
│       └── GetPasswordPolicyQueryHandler.cs (CREATE)
├── Domain/UknfPlatform.Domain.Auth/
│   └── Entities/
│       ├── User.cs (UPDATE: add LastPasswordChangeDate)
│       └── PasswordHistory.cs (CREATE)
├── Domain/UknfPlatform.Domain.Shared/
│   └── ValueObjects/
│       └── PasswordPolicy.cs (CREATE)
├── Infrastructure/UknfPlatform.Infrastructure.Identity/
│   └── Services/
│       ├── IPasswordHasher.cs (CREATE)
│       ├── PasswordHasher.cs (CREATE)
│       ├── IPasswordStrengthCalculator.cs (CREATE)
│       └── PasswordStrengthCalculator.cs (CREATE)
├── Infrastructure/UknfPlatform.Infrastructure.Persistence/
│   ├── Configurations/
│   │   └── PasswordHistoryConfiguration.cs (CREATE)
│   ├── Migrations/ (CREATE: Add_PasswordHistory_Table)
│   └── Repositories/
│       └── PasswordHistoryRepository.cs (CREATE)
```

Frontend files:
```
src/Frontend/uknf-platform-ui/src/app/
├── core/services/
│   └── auth.service.ts (UPDATE: add setPassword method)
├── features/auth/set-password/
│   ├── set-password.component.ts (CREATE)
│   ├── set-password.component.html (CREATE)
│   └── set-password.component.scss (CREATE)
├── shared/components/password-strength/
│   ├── password-strength.component.ts (CREATE)
│   ├── password-strength.component.html (CREATE)
│   └── password-strength.component.scss (CREATE)
```

### Data Models

**PasswordHistory Table Schema:**
```sql
CREATE TABLE PasswordHistory (
    Id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    UserId UUID NOT NULL,
    PasswordHash NVARCHAR(500) NOT NULL,
    CreatedDate DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    
    FOREIGN KEY (UserId) REFERENCES Users(Id) ON DELETE CASCADE,
    INDEX IX_PasswordHistory_UserId_CreatedDate (UserId, CreatedDate)
);
```

**Update Users Table:**
```sql
ALTER TABLE Users
ADD LastPasswordChangeDate DATETIME2 NULL;
```

**PasswordPolicy Configuration (appsettings.json):**
```json
{
  "PasswordPolicy": {
    "MinLength": 8,
    "MaxLength": 128,
    "RequireUppercase": true,
    "RequireLowercase": true,
    "RequireDigit": true,
    "RequireSpecialChar": true,
    "MinUniqueChars": 5,
    "PasswordHistoryCount": 5,
    "PasswordExpirationDays": 90,
    "ProhibitedPasswords": ["password", "123456", "qwerty"]
  }
}
```

### Password Hashing Implementation

**Using Argon2 (Recommended):**
```csharp
using Konscious.Security.Cryptography;

public class PasswordHasher : IPasswordHasher
{
    public string HashPassword(string password)
    {
        var salt = new byte[16];
        using (var rng = RandomNumberGenerator.Create())
        {
            rng.GetBytes(salt);
        }
        
        using (var argon2 = new Argon2id(Encoding.UTF8.GetBytes(password)))
        {
            argon2.Salt = salt;
            argon2.DegreeOfParallelism = 8;
            argon2.MemorySize = 65536; // 64 MB
            argon2.Iterations = 4;
            
            var hash = argon2.GetBytes(32);
            
            // Combine salt and hash for storage
            var hashBytes = new byte[salt.Length + hash.Length];
            Buffer.BlockCopy(salt, 0, hashBytes, 0, salt.Length);
            Buffer.BlockCopy(hash, 0, hashBytes, salt.Length, hash.Length);
            
            return Convert.ToBase64String(hashBytes);
        }
    }
    
    public bool VerifyPassword(string password, string hash)
    {
        var hashBytes = Convert.FromBase64String(hash);
        var salt = new byte[16];
        Buffer.BlockCopy(hashBytes, 0, salt, 0, salt.Length);
        
        using (var argon2 = new Argon2id(Encoding.UTF8.GetBytes(password)))
        {
            argon2.Salt = salt;
            argon2.DegreeOfParallelism = 8;
            argon2.MemorySize = 65536;
            argon2.Iterations = 4;
            
            var computedHash = argon2.GetBytes(32);
            
            for (int i = 0; i < computedHash.Length; i++)
            {
                if (hashBytes[i + salt.Length] != computedHash[i])
                    return false;
            }
            
            return true;
        }
    }
}
```

**Alternative: BCrypt (Simpler):**
```csharp
using BCrypt.Net;

public class PasswordHasher : IPasswordHasher
{
    public string HashPassword(string password)
    {
        return BCrypt.HashPassword(password, workFactor: 12);
    }
    
    public bool VerifyPassword(string password, string hash)
    {
        return BCrypt.Verify(password, hash);
    }
}
```

**NuGet Packages:**
- Argon2: `Konscious.Security.Cryptography.Argon2` (version 1.3.0)
- BCrypt: `BCrypt.Net-Next` (version 4.0.3)

### Password Strength Calculation

**Algorithm for Strength Score (0-100):**
```csharp
public int CalculateStrengthScore(string password)
{
    int score = 0;
    
    // Length (up to 40 points)
    score += Math.Min(password.Length * 4, 40);
    
    // Character diversity (up to 30 points)
    if (password.Any(char.IsUpper)) score += 10;
    if (password.Any(char.IsLower)) score += 10;
    if (password.Any(char.IsDigit)) score += 5;
    if (password.Any(ch => !char.IsLetterOrDigit(ch))) score += 5;
    
    // Uniqueness (up to 20 points)
    int uniqueChars = password.Distinct().Count();
    score += Math.Min(uniqueChars * 2, 20);
    
    // Penalties (up to -30 points)
    if (ContainsCommonPattern(password)) score -= 10;
    if (ContainsDictionaryWord(password)) score -= 10;
    if (ContainsRepeatingChars(password)) score -= 10;
    
    return Math.Max(0, Math.Min(score, 100));
}

public PasswordStrength GetStrengthLevel(int score)
{
    return score switch
    {
        <= 40 => PasswordStrength.Weak,
        <= 60 => PasswordStrength.Fair,
        <= 80 => PasswordStrength.Good,
        _ => PasswordStrength.Strong
    };
}
```

### Password Policy Validation

**FluentValidation Custom Validator:**
```csharp
public class PasswordPolicyValidator : AbstractValidator<string>
{
    private readonly PasswordPolicySettings _policy;
    
    public PasswordPolicyValidator(IOptions<PasswordPolicySettings> policy)
    {
        _policy = policy.Value;
        
        RuleFor(password => password)
            .NotEmpty().WithMessage("Password is required")
            .MinimumLength(_policy.MinLength)
                .WithMessage($"Password must be at least {_policy.MinLength} characters")
            .MaximumLength(_policy.MaxLength)
                .WithMessage($"Password must not exceed {_policy.MaxLength} characters");
        
        When(password => _policy.RequireUppercase, () =>
        {
            RuleFor(password => password)
                .Must(p => p.Any(char.IsUpper))
                .WithMessage("Password must contain at least one uppercase letter");
        });
        
        When(password => _policy.RequireLowercase, () =>
        {
            RuleFor(password => password)
                .Must(p => p.Any(char.IsLower))
                .WithMessage("Password must contain at least one lowercase letter");
        });
        
        When(password => _policy.RequireDigit, () =>
        {
            RuleFor(password => password)
                .Must(p => p.Any(char.IsDigit))
                .WithMessage("Password must contain at least one digit");
        });
        
        When(password => _policy.RequireSpecialChar, () =>
        {
            RuleFor(password => password)
                .Must(p => p.Any(ch => !char.IsLetterOrDigit(ch)))
                .WithMessage("Password must contain at least one special character");
        });
    }
}
```

### REST API Specification

**Endpoint 1:** POST `/api/auth/set-password`
- **Security:** None (public endpoint, validated by token)
- **Request Body:**
  ```json
  {
    "token": "ABC123...",
    "password": "MyP@ssw0rd!",
    "passwordConfirmation": "MyP@ssw0rd!"
  }
  ```
- **Success Response (200 OK):**
  ```json
  {
    "userId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "message": "Password set successfully. You can now log in.",
    "redirectUrl": "/auth/login"
  }
  ```
- **Error Responses:**
  - 400 Bad Request: Validation errors
    ```json
    {
      "errors": {
        "Password": ["Password must contain at least one uppercase letter"],
        "PasswordConfirmation": ["Passwords do not match"]
      }
    }
    ```

**Endpoint 2:** GET `/api/auth/password-policy`
- **Security:** None (public endpoint)
- **Response (200 OK):**
  ```json
  {
    "minLength": 8,
    "maxLength": 128,
    "requireUppercase": true,
    "requireLowercase": true,
    "requireDigit": true,
    "requireSpecialChar": true
  }
  ```

### Coding Standards (Key Points)

1. **Never Log Passwords:**
   ```csharp
   // ❌ WRONG
   _logger.LogInformation("User set password: {Password}", password);
   
   // ✅ CORRECT
   _logger.LogInformation("Password set successfully for user {UserId}", userId);
   ```

2. **Password Hashing:**
   - ALWAYS hash passwords before storage
   - NEVER store plaintext passwords
   - Use Argon2 or BCrypt (NOT SHA256, MD5, or custom algorithms)

3. **Password Confirmation:**
   - Validate on both client and server
   - Use constant-time comparison (built into Argon2/BCrypt verify)

4. **Password History:**
   - Store hashed passwords (not plaintext)
   - Query last N passwords efficiently (indexed query)
   - Verify against history using password hasher verify method

5. **Security Best Practices:**
   - Rate limit password set attempts (optional, can add later)
   - Clear password from memory after hashing (GC will handle)
   - Use HTTPS for all password operations
   - Don't reveal if user exists in error messages

### Frontend Password Strength Indicator

**Visual Design:**
```html
<div class="password-strength">
  <div class="strength-meter">
    <div class="strength-bar" 
         [ngClass]="strengthClass"
         [style.width.%]="strengthScore">
    </div>
  </div>
  <div class="strength-label">{{ strengthLabel }}</div>
</div>
```

**CSS (Tailwind):**
```scss
.strength-bar {
  &.weak { @apply bg-red-500; }
  &.fair { @apply bg-orange-500; }
  &.good { @apply bg-yellow-500; }
  &.strong { @apply bg-green-500; }
}
```

**TypeScript:**
```typescript
get strengthScore(): number {
  return this.calculateStrength(this.passwordControl.value);
}

get strengthClass(): string {
  if (this.strengthScore <= 40) return 'weak';
  if (this.strengthScore <= 60) return 'fair';
  if (this.strengthScore <= 80) return 'good';
  return 'strong';
}

get strengthLabel(): string {
  if (this.strengthScore <= 40) return 'Weak';
  if (this.strengthScore <= 60) return 'Fair';
  if (this.strengthScore <= 80) return 'Good';
  return 'Strong';
}
```

### Security Requirements

1. **Password Hashing:** Argon2 or BCrypt with appropriate work factor
2. **Password Policy:** Configurable complexity requirements
3. **Password History:** Prevent reuse of last N passwords
4. **Secure Transport:** HTTPS only for production
5. **Rate Limiting:** Consider adding to prevent brute force (future enhancement)
6. **Password Strength:** Client and server-side validation

### Audit Requirements

- Log password setting events with user ID and timestamp
- Log password policy violations (not the password itself!)
- Log password history checks
- Include correlation ID for request tracking

### Dependencies

**Prerequisites:**
- Story 1.1: User entity with PasswordHash field
- Story 1.2: ActivationToken entity and activation flow
- Password hashing library (Argon2 or BCrypt)

**Blocks:**
- Story 1.4: User Login (needs password to authenticate)
- Story 1.6: Password Change (reuses password policy and hashing)
- Story 1.7: Password Reset (reuses password policy and hashing)

### Testing Strategy

**Unit Tests:**
- PasswordHasher (hash, verify)
- PasswordPolicy validation (all rules)
- SetPasswordCommandHandler (all scenarios)
- Password strength calculation

**Integration Tests:**
- Full set password flow with database
- Password history prevention
- Password policy enforcement

**Security Tests:**
- Verify passwords are hashed (not plaintext in DB)
- Verify password history works
- Verify weak passwords are rejected

### Common Password Patterns to Block

Implement in PasswordStrengthCalculator:
- Sequential: "123456", "abcdef"
- Keyboard patterns: "qwerty", "asdfgh"
- Common passwords: "password", "admin", "welcome"
- Repeated characters: "aaaa", "1111"

### Error Messages

Be specific for user experience but secure:
- "Password must be at least 8 characters" ✅ (helpful)
- "Password must contain an uppercase letter" ✅ (helpful)
- "This password was used recently" ✅ (helpful, doesn't reveal history)
- "Activation link expired" ✅ (helpful)
- "Invalid token" ✅ (doesn't reveal details)

### Additional Notes

1. **Password Expiration:** Policy includes expiration (90 days), but enforcement is in Story 1.4 (login) where system checks if password expired and forces change
2. **Password Strength Real-Time:** Frontend should calculate strength as user types for better UX
3. **Show/Hide Password:** Include toggle button for better UX (especially mobile)
4. **Copy-Paste:** Allow password copy-paste (security research shows it's fine with password managers)
5. **Autocomplete:** Set `autocomplete="new-password"` for browser password managers
6. **Password Managers:** Design works well with password managers (they can generate strong passwords)

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-04 | 1.0 | Story created from Epic 1 | Product Owner |

---

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be populated by dev agent_

### Debug Log References

_To be populated by dev agent_

### Completion Notes

_To be populated by dev agent_

### File List

_To be populated by dev agent_

---

## QA Results

_This section will be populated by QA agent after story completion._

